<?xml version="1.0" encoding="utf-8"?>
<feed xmlns="http://www.w3.org/2005/Atom">
  <title>康帅傅的blog</title>
  
  <subtitle>Stay Hungry. Stay Foolish.</subtitle>
  <link href="/atom.xml" rel="self"/>
  
  <link href="https://kanper.top/"/>
  <updated>2018-06-10T03:19:47.357Z</updated>
  <id>https://kanper.top/</id>
  
  <author>
    <name>kanper tony_kanper@hotmail.com</name>
    
  </author>
  
  <generator uri="http://hexo.io/">Hexo</generator>
  
  <entry>
    <title>Google I/O 2018</title>
    <link href="https://kanper.top/2018/06/10/Google-I-O-2018/"/>
    <id>https://kanper.top/2018/06/10/Google-I-O-2018/</id>
    <published>2018-06-10T01:55:27.000Z</published>
    <updated>2018-06-10T03:19:47.357Z</updated>
    
    <content type="html"><![CDATA[<p>上个月在YouTube上观看了Google IO 2018年大会，谷歌首席执行官皮蔡带来了开幕式演讲，印象最深刻的是皮蔡展示的关于Google Assistant帮助主人预定剪头发，惊讶于谷歌的人工智能已经发展到这个地步了。</p><h1>大会最重要的关键词</h1><p>这次大会最重要的关键词是——AI，即人工智能，你可以使用手机发出语音指令，Google Assistant就能够根据指令完成后续操作，诸如：预定剪头发、导航路线、发现最近你特别喜欢的一场show、能够分析你的应用使用情况智能的为手机分配资源等。并于2015年开源的机器学习Tensorflow,迎来了其爆炸式的增长，机器学习、人工智能越来越被大家所熟知。</p><h2>Google Assistant</h2><p>作为AI最核心的东西，几乎都要成精了，在视频中，听者甚至无法分辨是机器还是人类，当然这仅仅是英文，中文语气更加复杂，人们还是能够分辨，就英语来说，能在适合的的场景发出适合的语气词，还是让这场show惊艳了一把。另外不需要每次对话之前都说Hey Google以唤醒Google Assistant的功能。</p><p>除了自然语言的处理，还有深度学习，例如你正在问Google关于某个餐馆的信息，它甚至将参观的所有菜单进行罗列。</p><p>初次之外，皮蔡和他的团队认为，有些很不必要的电话是不需要人力是亲自询问的，而机器做到了这一点。例如，某些商场在周末的闭店时间变化，通过Google Assistant，可以模拟人类打电话询问商家闭店时间，然后提醒用户，更新tips。</p><h2>Picture</h2><p>排名不分先后，但我认为的第二个亮点，谷歌能够通过图像算法辨识出图片，以前人类辨识图片的错误率为15%，而机器仅为5%，当然你说我拍了一张谁谁谁的照片，Google却不知道其是谁，那我就没什么话可说了。其中最厉害的是，在医学上的使用，通过对人类视网膜的图像分析，Google图片可以分辨出患者的心血管疾病，从而在发病初期进行控制，这个技术甚至比经验丰富的眼科医生的正确率提高2～3倍。</p><blockquote><p>越来越多的糖尿病患者因视网膜病变而致盲，全世界大约有 4.15 亿的糖尿病患者正面临这一威胁。如果能有效捕捉到视网膜病变的征兆特征，病人是可以通过早期治疗而避免失明。但倘若未能对其作出及时的诊断，错过治疗最佳时机，糖尿病引起的失明将是无法医治的。</p><footer><strong>Sunshine_lady</strong><cite><a href="https://www.leiphone.com/news/201611/u89FFlar22fDNoKA.html" target="_blank" rel="noopener">谷歌化身眼科专家，用深度学习诊断糖尿病视网膜病变</a></cite></footer></blockquote><p>屌不屌，看图片,图片进行自动分类</p><img src="/2018/06/10/Google-I-O-2018/GooglePhotos.png" class="rounded" width="400" height="400" title="谷歌图片"><p>谷歌相册能够根据面部识别出同一个人，将同样的任务归位一组，类似的还有iCloud的地点归类功能，还有事件归类，例如：食物、天空、自然景观的归类</p><p>还能够将图片拍摄下来，抓去图片中的文字，如果拍摄的是衣服，Google Lens甚至显示出衣服在商场中的同款，详情参见</p><img src="/2018/06/10/Google-I-O-2018/12.gif" class="rounded" width="400" height="400" title="谷歌图片3"><hr><img src="/2018/06/10/Google-I-O-2018/13.gif" class="rounded" width="400" height="400" title="谷歌图片2"><h2>Android P</h2><p>最新一代的android p系统，提倡一个数字健康生活，翻译过来是这个意思吧，视频原文采用的是digital wellbeing, well-being本义为康乐（身体健康、<strong>心里健康</strong>、经济宽裕），提倡以人为本。</p><p>这里不得不吐槽一下国内安卓混乱的现象了，各大厂商为了争夺用户流量，可谓真是十八般武艺，样样精通。手机锁屏唤醒次数太多，发一些标题党的notification，某三大视频厂常年都是娱乐热搜视频的推送，icon上的红点对于强迫症的人来讲，不要太难受。博主以苹果来看，这是关掉了大部分提醒后的结果，而且，在你打开没有推送信息的APP的生活，癞皮狗似的让你打开推送，怕你错过，对不起，我真心不喜欢你们的推送，我用你们的app仅仅是我有需要的时候，平时请老实给我在墙角蹲好！苹果都这样了，更别说安卓后端运行的那些service，有没有不通过用户的同意就收发数据的我真是不知道，希望有大神可以抓包看看。</p><img src="/2018/06/10/Google-I-O-2018/11.png" class="rounded" width="400" height="400" title="谷歌图片4"><img src="/2018/06/10/Google-I-O-2018/14.jpeg" class="rounded" width="400" height="400" title="谷歌图片5"><p>回到正题，android p系统有什么特别独特的功能呢？比如：你对某个app的依赖过度，你可以设置每天玩多少时间，到了时间之后，app图片会自动黑白化，提醒你使用过度了，并且在你打开app会有强烈的提示。dash界面可以查看安装的app的唤醒次数，你每天使用的情况，Google可以根据你的使用情况，只能的分配系统内存、电量等，但是还是很担心隐私泄露的问题，毕竟这些是要通过远程计算的，用一些系统的本地功能就很开心了。</p><p>Google甚至不惜以自己应用来开刀，提倡人们健康生活，对YouTube过度依赖的人，在过度依赖时间生效时，会收到YouTube提示休息♨️ Awesome! 💥 ,系统还有许多人性化的设置，不仅仅是UI方面，Action bar也做了一些修改来适应人的使用习惯。</p><h2>Material design</h2><p>谷歌的设计总是比较野性的，现在它的UI看起来融入了更多的设计者自己的想法，谷歌不再强制建议设计者的UI样式，反而为你提供很多范例，供你参考，你只需要按照他的设计来，融入你自己的设计理念，谷歌提倡开放，只是说你的UI位置需要更符合使用习惯，你使用怎样的字体颜色，以及你的页面风格等你都可以最大化的设计，但其实UI位置还是根据机器按钮来设计的比较好。</p><p>一个合格的产品设计师，都应该去通读Material design，了解其设计的初衷，这些设计都有它这么设计的道理，没有特别大的需求还是尽力不要修改它</p><h2>Google 大会的其他</h2><p>当然Google大会还有许多其他有趣的事情，例如自动驾驶；又或者说他们将Google News进行了提升，但讲真对于国内用户来讲还是期待百度的自动驾驶吧，我不关注新闻，因为在国内，新闻会自动关注我，手动滑稽哈哈。</p><h2>结语</h2><p>任何时候看国外的产品和国内的产品，总觉得，别人做得好，不敢用，国内的有做得好的非常棒，如支付宝、WeChat，国内其他的真的是不太适合强迫症，每天几百条红字在Icons上真心看着着急。</p><p>国外的东西用起来麻烦，需要一定的英文基础，很多东西真的是不符合中国人的习惯的，到现在也觉得有的设计反人类，也就老外能习惯吧。</p><p>对于文档方面我更喜欢国外的，国外的教程、视频，都是把学习者当作一个傻逼在教，一个Hello World甚至会教你如何从网站上下载jdk，一个截图一个窗口的教你如何安装jdk，反观国内，直接一句话或者加一句话——“你一直点下一步，知道输入java-version看到啥就行了”，“还不会？你邮箱给我，我给你一个jdk”。哈哈，这就造成我去看的时候，几乎直接跳过1～5节课程，跳着看课程。国内的有的都说不明白，需要提问回答，哈哈，各有千秋不是么</p><h2>参考</h2><ul><li><a href="https://www.youtube.com/watch?v=ogfYd705cRs" title="Google IO" target="_blank" rel="noopener">谷歌开发者大会2018 Google IO</a></li><li><a href="https://www.zhihu.com/question/275930989" title="Google I/O 2018有哪些亮点？" target="_blank" rel="noopener">知乎 Google I/O</a></li></ul>]]></content>
    
    <summary type="html">
    
      
      
        &lt;p&gt;上个月在YouTube上观看了Google IO 2018年大会，谷歌首席执行官皮蔡带来了开幕式演讲，印象最深刻的是皮蔡展示的关于Google Assistant帮助主人预定剪头发，惊讶于谷歌的人工智能已经发展到这个地步了。&lt;/p&gt;
&lt;h1&gt;大会最重要的关键词&lt;/h1&gt;
&lt;
      
    
    </summary>
    
      <category term="分享" scheme="https://kanper.top/categories/%E5%88%86%E4%BA%AB/"/>
    
    
      <category term="移动端" scheme="https://kanper.top/tags/%E7%A7%BB%E5%8A%A8%E7%AB%AF/"/>
    
      <category term="谷歌" scheme="https://kanper.top/tags/%E8%B0%B7%E6%AD%8C/"/>
    
  </entry>
  
  <entry>
    <title>Java中的HashMap</title>
    <link href="https://kanper.top/2018/06/05/Java%E4%B8%AD%E7%9A%84HashMap/"/>
    <id>https://kanper.top/2018/06/05/Java中的HashMap/</id>
    <published>2018-06-05T03:15:32.000Z</published>
    <updated>2018-06-05T09:00:53.758Z</updated>
    
    <content type="html"><![CDATA[<blockquote><p>HashMap是Java程序员使用频率最高的用于映射(键值对)处理的数据类型。随着JDK（Java Developmet Kit）版本的更新，JDK1.8对HashMap底层的实现进行了优化，例如引入红黑树的数据结构和扩容的优化等。本文结合JDK1.7和JDK1.8的区别，深入探讨HashMap的结构实现和功能原理。</p><footer><strong>美团技术点评</strong><cite><a href="https://tech.meituan.com/java-hashmap.html" target="_blank" rel="noopener">Java 8系列之重新认识HashMap</a></cite></footer></blockquote><h1>Java Map类图</h1><p>主要有四个常用的实现类，分别是HashMap、Hashtable、LinkedHashMap和TreeMap</p><img src="/2018/06/05/Java中的HashMap/java.util.map类图.png" class="rounded" width="400" height="400" title="java.util.map类图"><ul><li>HashMap：它根据键的hashCode值存储数据，大多数情况下可以直接定位到它的值，因而具有很快的访问速度，但遍历顺序却是不确定的。 HashMap最多只允许一条记录的键为null，允许多条记录的值为null。HashMap非线程安全，即任一时刻可以有多个线程同时写HashMap，可能会导致数据的不一致。如果需要满足线程安全，可以用 Collections的synchronizedMap方法使HashMap具有线程安全的能力，或者使用ConcurrentHashMap，后者更优</li><li>Hashtable：Hashtable是遗留类，很多映射的常用功能与HashMap类似，不同的是它承自Dictionary类，并且是线程安全的，任一时间只有一个线程能写Hashtable，并发性不如ConcurrentHashMap，因为ConcurrentHashMap引入了分段锁。Hashtable不建议在新代码中使用，不需要线程安全的场合可以用HashMap替换，需要线程安全的场合可以用ConcurrentHashMap替换。</li><li>LinkedHashMap：LinkedHashMap是HashMap的一个子类，保存了记录的插入顺序，在用Iterator遍历LinkedHashMap时，先得到的记录肯定是先插入的，也可以在构造时带参数，按照访问次序排序。</li><li>TreeMap：TreeMap实现SortedMap接口，能够把它保存的记录根据键排序，默认是按键值的升序排序，也可以指定排序的比较器，当用Iterator遍历TreeMap时，得到的记录是排过序的。如果使用排序的映射，建议使用TreeMap。在使用TreeMap时，key必须实现Comparable接口或者在构造TreeMap传入自定义的Comparator，否则会在运行时抛出java.lang.ClassCastException类型的异常。</li></ul><p>对于上述四种Map类型的类，要求映射中的key是不可变对象。不可变对象是该对象在创建后它的哈希值不会被改变。如果对象的哈希值发生变化，Map对象很可能就定位不到映射的位置了。（所以一般喜欢用String/Integer来做key，因为它是final的）</p><h2>存储结构</h2><p>引用YouTube上的一个阿三哥的视频，能够更好的理解</p><div class="video-container"><iframe src="//www.youtube.com/embed/c3RVW3KGIIE" frameborder="0" allowfullscreen></iframe></div><p>文中主要叙述了其实HashMap是初始化一个长度为16的数组，因为Java里面所有类都继承父类Object的hashcode方法，所有类都可以通过hashcode方法返回一个定长的int数字，初始化为0。</p><img src="/2018/06/05/Java中的HashMap/hashcode.png" class="rounded" width="400" height="400" title="hashcode方法"><p>通过调用put方法，首先计算key的hash值</p><img src="/2018/06/05/Java中的HashMap/put.png" class="rounded" width="400" height="400" title="put方法"><p>然后调用putVal方法</p><img src="/2018/06/05/Java中的HashMap/putVal.png" class="rounded" width="400" height="400" title="putVal方法"><p><strong>引用美团的讲解如下</strong></p><img src="/2018/06/05/Java中的HashMap/hashMap内存结构图.png" class="rounded" width="400" height="400" title="hashMap内存结构图"><p>(1) 从源码可知，HashMap类中有一个非常重要的字段，就是 Node[] table，即哈希桶数组，明显它是一个Node的数组。我们来看Node[JDK1.8]是何物。</p><figure class="highlight java"><figcaption><span>Node</span></figcaption><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">static</span> <span class="class"><span class="keyword">class</span> <span class="title">Node</span>&lt;<span class="title">K</span>,<span class="title">V</span>&gt; <span class="keyword">implements</span> <span class="title">Map</span>.<span class="title">Entry</span>&lt;<span class="title">K</span>,<span class="title">V</span>&gt; </span>&#123;</span><br><span class="line">        <span class="keyword">final</span> <span class="keyword">int</span> hash;    <span class="comment">//用来定位数组索引位置</span></span><br><span class="line">        <span class="keyword">final</span> K key;</span><br><span class="line">        V value;</span><br><span class="line">        Node&lt;K,V&gt; next;   <span class="comment">//链表的下一个node</span></span><br><span class="line"></span><br><span class="line">        Node(<span class="keyword">int</span> hash, K key, V value, Node&lt;K,V&gt; next) &#123; ... &#125;</span><br><span class="line">        <span class="function"><span class="keyword">public</span> <span class="keyword">final</span> K <span class="title">getKey</span><span class="params">()</span></span>&#123; ... &#125;</span><br><span class="line">        <span class="function"><span class="keyword">public</span> <span class="keyword">final</span> V <span class="title">getValue</span><span class="params">()</span> </span>&#123; ... &#125;</span><br><span class="line">        <span class="function"><span class="keyword">public</span> <span class="keyword">final</span> String <span class="title">toString</span><span class="params">()</span> </span>&#123; ... &#125;</span><br><span class="line">        <span class="function"><span class="keyword">public</span> <span class="keyword">final</span> <span class="keyword">int</span> <span class="title">hashCode</span><span class="params">()</span> </span>&#123; ... &#125;</span><br><span class="line">        <span class="function"><span class="keyword">public</span> <span class="keyword">final</span> V <span class="title">setValue</span><span class="params">(V newValue)</span> </span>&#123; ... &#125;</span><br><span class="line">        <span class="function"><span class="keyword">public</span> <span class="keyword">final</span> <span class="keyword">boolean</span> <span class="title">equals</span><span class="params">(Object o)</span> </span>&#123; ... &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>Node是HashMap的一个内部类，实现了Map.Entry接口，本质是就是一个映射(键值对)。上图中的每个黑色圆点就是一个Node对象。</p><p>(2)  HashMap就是使用哈希表来存储的。哈希表为解决冲突，可以采用开放地址法和链地址法等来解决问题，Java中HashMap采用了链地址法。链地址法，简单来说，就是数组加链表的结合。在每个数组元素上都一个链表结构，当数据被Hash后，得到数组下标，把数据放在对应下标元素的链表上。例如程序执行下面代码：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">map.put(<span class="string">"美团"</span>,<span class="string">"小美"</span>);</span><br></pre></td></tr></table></figure><p>系统将调用&quot;美团&quot;这个key的hashCode()方法得到其hashCode 值（该方法适用于每个Java对象），然后再通过Hash算法的后两步运算（高位运算和取模运算，下文有介绍）来定位该键值对的存储位置，有时两个key会定位到相同的位置，表示发生了Hash碰撞。当然Hash算法计算结果越分散均匀，Hash碰撞的概率就越小，map的存取效率就会越高。</p><p>如果哈希桶数组很大，即使较差的Hash算法也会比较分散，如果哈希桶数组数组很小，即使好的Hash算法也会出现较多碰撞，所以就需要在空间成本和时间成本之间权衡，其实就是在根据实际情况确定哈希桶数组的大小，并在此基础上设计好的hash算法减少Hash碰撞。那么通过什么方式来控制map使得Hash碰撞的概率又小，哈希桶数组（Node[] table）占用空间又少呢？答案就是好的Hash算法和扩容机制。</p><p>在理解Hash和扩容流程之前，我们得先了解下HashMap的几个字段。从HashMap的默认构造函数源码可知，构造函数就是对下面几个字段进行初始化，源码如下：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">int</span> threshold;             <span class="comment">// 所能容纳的key-value对极限</span></span><br><span class="line"><span class="keyword">final</span> <span class="keyword">float</span> loadFactor;    <span class="comment">// 负载因子</span></span><br><span class="line"><span class="keyword">int</span> modCount;  </span><br><span class="line"><span class="keyword">int</span> size;</span><br></pre></td></tr></table></figure><p>首先，Node[] table的初始化长度length(默认值是16)，Load factor为负载因子(默认值是0.75)，threshold是HashMap所能容纳的最大数据量的Node(键值对)个数。threshold = length * Load factor。也就是说，在数组定义好长度之后，负载因子越大，所能容纳的键值对个数越多。</p><p>结合负载因子的定义公式可知，threshold就是在此Load factor和length(数组长度)对应下允许的最大元素数目，超过这个数目就重新resize(扩容)，扩容后的HashMap容量是之前容量的两倍。默认的负载因子0.75是对空间和时间效率的一个平衡选择，建议大家不要修改，除非在时间和空间比较特殊的情况下，如果内存空间很多而又对时间效率要求很高，可以降低负载因子Load factor的值；相反，如果内存空间紧张而对时间效率要求不高，可以增加负载因子loadFactor的值，这个值可以大于1。</p><p>size这个字段其实很好理解，就是HashMap中实际存在的键值对数量。注意和table的长度length、容纳最大键值对数量threshold的区别。而modCount字段主要用来记录HashMap内部结构发生变化的次数，主要用于迭代的快速失败。强调一点，内部结构发生变化指的是结构发生变化，例如put新键值对，但是某个key对应的value值被覆盖不属于结构变化。</p><p>在HashMap中，哈希桶数组table的长度length大小必须为2的n次方(一定是合数)，这是一种非常规的设计，常规的设计是把桶的大小设计为素数。相对来说素数导致冲突的概率要小于合数，具体证明可以参考<a href="http://blog.csdn.net/liuqiyao_01/article/details/14475159" target="_blank" rel="noopener">http://blog.csdn.net/liuqiyao_01/article/details/14475159</a>，Hashtable初始化桶大小为11，就是桶大小设计为素数的应用（Hashtable扩容后不能保证还是素数）。HashMap采用这种非常规设计，主要是为了在取模和扩容时做优化，同时为了减少冲突，HashMap定位哈希桶索引位置时，也加入了高位参与运算的过程。</p><p>这里存在一个问题，即使负载因子和Hash算法设计的再合理，也免不了会出现拉链过长的情况，一旦出现拉链过长，则会严重影响HashMap的性能。于是，在JDK1.8版本中，对数据结构做了进一步的优化，引入了红黑树。而当链表长度太长（默认超过8）时，链表就转换为红黑树，利用红黑树快速增删改查的特点提高HashMap的性能，其中会用到红黑树的插入、删除、查找等算法。</p><p>简单说来就是如上面的视频所说的将大的放在左边</p><h2>功能实现-方法</h2><h3>1.确定哈希桶数组索引位置</h3><p>不管增加、删除、查找键值对，定位到哈希桶数组的位置都是很关键的第一步。前面说过HashMap的数据结构是数组和链表的结合，所以我们当然希望这个HashMap里面的元素位置尽量分布均匀些，尽量使得每个位置上的元素数量只有一个，那么当我们用hash算法求得这个位置的时候，马上就可以知道对应位置的元素就是我们要的，不用遍历链表，大大优化了查询的效率。HashMap定位数组索引位置，直接决定了hash方法的离散性能。先看看源码的实现(方法一+方法二):</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line">方法一：</span><br><span class="line"><span class="function"><span class="keyword">static</span> <span class="keyword">final</span> <span class="keyword">int</span> <span class="title">hash</span><span class="params">(Object key)</span> </span>&#123;   <span class="comment">//jdk1.8 &amp; jdk1.7</span></span><br><span class="line">     <span class="keyword">int</span> h;</span><br><span class="line">     <span class="comment">// h = key.hashCode() 为第一步 取hashCode值</span></span><br><span class="line">     <span class="comment">// h ^ (h &gt;&gt;&gt; 16)  为第二步 高位参与运算</span></span><br><span class="line">     <span class="keyword">return</span> (key == <span class="keyword">null</span>) ? <span class="number">0</span> : (h = key.hashCode()) ^ (h &gt;&gt;&gt; <span class="number">16</span>);</span><br><span class="line">&#125;</span><br><span class="line">方法二：</span><br><span class="line"><span class="function"><span class="keyword">static</span> <span class="keyword">int</span> <span class="title">indexFor</span><span class="params">(<span class="keyword">int</span> h, <span class="keyword">int</span> length)</span> </span>&#123;  <span class="comment">//jdk1.7的源码，jdk1.8没有这个方法，但是实现原理一样的</span></span><br><span class="line">     <span class="keyword">return</span> h &amp; (length-<span class="number">1</span>);  <span class="comment">//第三步 取模运算</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>这里的Hash算法本质上就是三步：<strong>取key的hashCode值、高位运算、取模运算。</strong></p><p>对于任意给定的对象，只要它的hashCode()返回值相同，那么程序调用方法一所计算得到的Hash码值总是相同的。我们首先想到的就是把hash值对数组长度取模运算，这样一来，元素的分布相对来说是比较均匀的。但是，模运算的消耗还是比较大的，在HashMap中是这样做的：调用方法二来计算该对象应该保存在table数组的哪个索引处。</p><p>这个方法非常巧妙，它通过h &amp; (table.length -1)来得到该对象的保存位，而HashMap底层数组的长度总是2的n次方，这是HashMap在速度上的优化。当length总是2的n次方时，h&amp; (length-1)运算等价于对length取模，也就是h%length，但是&amp;比%具有更高的效率。</p><p>在JDK1.8的实现中，优化了高位运算的算法，通过hashCode()的高16位异或低16位实现的：(h = k.hashCode()) ^ (h &gt;&gt;&gt; 16)，主要是从速度、功效、质量来考虑的，这么做可以在数组table的length比较小的时候，也能保证考虑到高低Bit都参与到Hash的计算中，同时不会有太大的开销。</p><p>下面举例说明下，n为table的长度。</p><img src="/2018/06/05/Java中的HashMap/hashMap哈希算法例图.png" class="rounded" width="400" height="400" title="hashMap哈希算法例图"><h3>2.分析HashMap的put方法</h3><p>HashMap的put方法执行过程可以通过下图来理解</p><img src="/2018/06/05/Java中的HashMap/hashMapput方法执行流程图.png" class="rounded" width="400" height="400" title="hashMap put方法执行流程图"><ol><li>判断键值对数组table[i]是否为空或为null，否则执行resize()进行扩容；</li><li>根据键值key计算hash值得到插入的数组索引i，如果table[i]==null，直接新建节点添加，转向[6]，如果table[i]不为空，转向[3]；</li><li>判断table[i]的首个元素是否和key一样，如果相同直接覆盖value，否则转向[4]，这里的相同指的是hashCode以及equals相同；</li><li>判断table[i] 是否为treeNode，即table[i] 是否是红黑树，如果是红黑树，则直接在树中插入键值对，否则转向[5];</li><li>遍历table[i]，判断链表长度是否大于8，大于8的话把链表转换为红黑树，在红黑树中执行插入操作，否则进行链表的插入操作；遍历过程中若发现key已经存在直接覆盖value即可；</li><li>插入成功后，判断实际存在的键值对数量size是否超多了最大容量threshold，如果超过，进行扩容。</li></ol><p>JDK1.8HashMap的put方法源码如下:</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br></pre></td><td class="code"><pre><span class="line"> <span class="number">1</span> <span class="function"><span class="keyword">public</span> V <span class="title">put</span><span class="params">(K key, V value)</span> </span>&#123;</span><br><span class="line"> <span class="number">2</span>     <span class="comment">// 对key的hashCode()做hash</span></span><br><span class="line"> <span class="number">3</span>     <span class="keyword">return</span> putVal(hash(key), key, value, <span class="keyword">false</span>, <span class="keyword">true</span>);</span><br><span class="line"> <span class="number">4</span> &#125;</span><br><span class="line"> <span class="number">5</span></span><br><span class="line"> <span class="number">6</span> <span class="function"><span class="keyword">final</span> V <span class="title">putVal</span><span class="params">(<span class="keyword">int</span> hash, K key, V value, <span class="keyword">boolean</span> onlyIfAbsent,</span></span></span><br><span class="line"><span class="function"><span class="params"> <span class="number">7</span>                <span class="keyword">boolean</span> evict)</span> </span>&#123;</span><br><span class="line"> <span class="number">8</span>     Node&lt;K,V&gt;[] tab; Node&lt;K,V&gt; p; <span class="keyword">int</span> n, i;</span><br><span class="line"> <span class="number">9</span>     <span class="comment">// 步骤①：tab为空则创建</span></span><br><span class="line"><span class="number">10</span>     <span class="keyword">if</span> ((tab = table) == <span class="keyword">null</span> || (n = tab.length) == <span class="number">0</span>)</span><br><span class="line"><span class="number">11</span>         n = (tab = resize()).length;</span><br><span class="line"><span class="number">12</span>     <span class="comment">// 步骤②：计算index，并对null做处理</span></span><br><span class="line"><span class="number">13</span>     <span class="keyword">if</span> ((p = tab[i = (n - <span class="number">1</span>) &amp; hash]) == <span class="keyword">null</span>)</span><br><span class="line"><span class="number">14</span>         tab[i] = newNode(hash, key, value, <span class="keyword">null</span>);</span><br><span class="line"><span class="number">15</span>     <span class="keyword">else</span> &#123;</span><br><span class="line"><span class="number">16</span>         Node&lt;K,V&gt; e; K k;</span><br><span class="line"><span class="number">17</span>         <span class="comment">// 步骤③：节点key存在，直接覆盖value</span></span><br><span class="line"><span class="number">18</span>         <span class="keyword">if</span> (p.hash == hash &amp;&amp;</span><br><span class="line"><span class="number">19</span>             ((k = p.key) == key || (key != <span class="keyword">null</span> &amp;&amp; key.equals(k))))</span><br><span class="line"><span class="number">20</span>             e = p;</span><br><span class="line"><span class="number">21</span>         <span class="comment">// 步骤④：判断该链为红黑树</span></span><br><span class="line"><span class="number">22</span>         <span class="keyword">else</span> <span class="keyword">if</span> (p <span class="keyword">instanceof</span> TreeNode)</span><br><span class="line"><span class="number">23</span>             e = ((TreeNode&lt;K,V&gt;)p).putTreeVal(<span class="keyword">this</span>, tab, hash, key, value);</span><br><span class="line"><span class="number">24</span>         <span class="comment">// 步骤⑤：该链为链表</span></span><br><span class="line"><span class="number">25</span>         <span class="keyword">else</span> &#123;</span><br><span class="line"><span class="number">26</span>             <span class="keyword">for</span> (<span class="keyword">int</span> binCount = <span class="number">0</span>; ; ++binCount) &#123;</span><br><span class="line"><span class="number">27</span>                 <span class="keyword">if</span> ((e = p.next) == <span class="keyword">null</span>) &#123;</span><br><span class="line"><span class="number">28</span>                     p.next = newNode(hash, key,value,<span class="keyword">null</span>);</span><br><span class="line">                        <span class="comment">//链表长度大于8转换为红黑树进行处理</span></span><br><span class="line"><span class="number">29</span>                     <span class="keyword">if</span> (binCount &gt;= TREEIFY_THRESHOLD - <span class="number">1</span>) <span class="comment">// -1 for 1st  </span></span><br><span class="line"><span class="number">30</span>                         treeifyBin(tab, hash);</span><br><span class="line"><span class="number">31</span>                     <span class="keyword">break</span>;</span><br><span class="line"><span class="number">32</span>                 &#125;</span><br><span class="line">                    <span class="comment">// key已经存在直接覆盖value</span></span><br><span class="line"><span class="number">33</span>                 <span class="keyword">if</span> (e.hash == hash &amp;&amp;</span><br><span class="line"><span class="number">34</span>                     ((k = e.key) == key || (key != <span class="keyword">null</span> &amp;&amp; key.equals(k))))</span><br><span class="line"><span class="number">35</span>                            <span class="keyword">break</span>;</span><br><span class="line"><span class="number">36</span>                 p = e;</span><br><span class="line"><span class="number">37</span>             &#125;</span><br><span class="line"><span class="number">38</span>         &#125;</span><br><span class="line"><span class="number">39</span></span><br><span class="line"><span class="number">40</span>         <span class="keyword">if</span> (e != <span class="keyword">null</span>) &#123; <span class="comment">// existing mapping for key</span></span><br><span class="line"><span class="number">41</span>             V oldValue = e.value;</span><br><span class="line"><span class="number">42</span>             <span class="keyword">if</span> (!onlyIfAbsent || oldValue == <span class="keyword">null</span>)</span><br><span class="line"><span class="number">43</span>                 e.value = value;</span><br><span class="line"><span class="number">44</span>             afterNodeAccess(e);</span><br><span class="line"><span class="number">45</span>             <span class="keyword">return</span> oldValue;</span><br><span class="line"><span class="number">46</span>         &#125;</span><br><span class="line"><span class="number">47</span>     &#125;</span><br><span class="line"></span><br><span class="line"><span class="number">48</span>     ++modCount;</span><br><span class="line"><span class="number">49</span>     <span class="comment">// 步骤⑥：超过最大容量 就扩容</span></span><br><span class="line"><span class="number">50</span>     <span class="keyword">if</span> (++size &gt; threshold)</span><br><span class="line"><span class="number">51</span>         resize();</span><br><span class="line"><span class="number">52</span>     afterNodeInsertion(evict);</span><br><span class="line"><span class="number">53</span>     <span class="keyword">return</span> <span class="keyword">null</span>;</span><br><span class="line"><span class="number">54</span> &#125;</span><br></pre></td></tr></table></figure><h3>3.扩容机制</h3><p>扩容(resize)就是重新计算容量，向HashMap对象里不停的添加元素，而HashMap对象内部的数组无法装载更多的元素时，对象就需要扩大数组的长度，以便能装入更多的元素。当然Java里的数组是无法自动扩容的，方法是使用一个新的数组代替已有的容量小的数组，就像我们用一个小桶装水，如果想装更多的水，就得换大水桶。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"> <span class="number">1</span> <span class="function"><span class="keyword">void</span> <span class="title">resize</span><span class="params">(<span class="keyword">int</span> newCapacity)</span> </span>&#123;   <span class="comment">//传入新的容量</span></span><br><span class="line"> <span class="number">2</span>     Entry[] oldTable = table;    <span class="comment">//引用扩容前的Entry数组</span></span><br><span class="line"> <span class="number">3</span>     <span class="keyword">int</span> oldCapacity = oldTable.length;</span><br><span class="line"> <span class="number">4</span>     <span class="keyword">if</span> (oldCapacity == MAXIMUM_CAPACITY) &#123;  <span class="comment">//扩容前的数组大小如果已经达到最大(2^30)了</span></span><br><span class="line"> <span class="number">5</span>         threshold = Integer.MAX_VALUE; <span class="comment">//修改阈值为int的最大值(2^31-1)，这样以后就不会扩容了</span></span><br><span class="line"> <span class="number">6</span>         <span class="keyword">return</span>;</span><br><span class="line"> <span class="number">7</span>     &#125;</span><br><span class="line"> <span class="number">8</span>  </span><br><span class="line"> <span class="number">9</span>     Entry[] newTable = <span class="keyword">new</span> Entry[newCapacity];  <span class="comment">//初始化一个新的Entry数组</span></span><br><span class="line"><span class="number">10</span>     transfer(newTable);                         <span class="comment">//！！将数据转移到新的Entry数组里</span></span><br><span class="line"><span class="number">11</span>     table = newTable;                           <span class="comment">//HashMap的table属性引用新的Entry数组</span></span><br><span class="line"><span class="number">12</span>     threshold = (<span class="keyword">int</span>)(newCapacity * loadFactor);<span class="comment">//修改阈值</span></span><br><span class="line"><span class="number">13</span> &#125;</span><br></pre></td></tr></table></figure><p>这里就是使用一个容量更大的数组来代替已有的容量小的数组，transfer()方法将原有Entry数组的元素拷贝到新的Entry数组里。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line"> <span class="number">1</span> <span class="function"><span class="keyword">void</span> <span class="title">transfer</span><span class="params">(Entry[] newTable)</span> </span>&#123;</span><br><span class="line"> <span class="number">2</span>     Entry[] src = table;                   <span class="comment">//src引用了旧的Entry数组</span></span><br><span class="line"> <span class="number">3</span>     <span class="keyword">int</span> newCapacity = newTable.length;</span><br><span class="line"> <span class="number">4</span>     <span class="keyword">for</span> (<span class="keyword">int</span> j = <span class="number">0</span>; j &lt; src.length; j++) &#123; <span class="comment">//遍历旧的Entry数组</span></span><br><span class="line"> <span class="number">5</span>         Entry&lt;K,V&gt; e = src[j];             <span class="comment">//取得旧Entry数组的每个元素</span></span><br><span class="line"> <span class="number">6</span>         <span class="keyword">if</span> (e != <span class="keyword">null</span>) &#123;</span><br><span class="line"> <span class="number">7</span>             src[j] = <span class="keyword">null</span>;<span class="comment">//释放旧Entry数组的对象引用（for循环后，旧的Entry数组不再引用任何对象）</span></span><br><span class="line"> <span class="number">8</span>             <span class="keyword">do</span> &#123;</span><br><span class="line"> <span class="number">9</span>                 Entry&lt;K,V&gt; next = e.next;</span><br><span class="line"><span class="number">10</span>                 <span class="keyword">int</span> i = indexFor(e.hash, newCapacity); <span class="comment">//！！重新计算每个元素在数组中的位置</span></span><br><span class="line"><span class="number">11</span>                 e.next = newTable[i]; <span class="comment">//标记[1]</span></span><br><span class="line"><span class="number">12</span>                 newTable[i] = e;      <span class="comment">//将元素放在数组上</span></span><br><span class="line"><span class="number">13</span>                 e = next;             <span class="comment">//访问下一个Entry链上的元素</span></span><br><span class="line"><span class="number">14</span>             &#125; <span class="keyword">while</span> (e != <span class="keyword">null</span>);</span><br><span class="line"><span class="number">15</span>         &#125;</span><br><span class="line"><span class="number">16</span>     &#125;</span><br><span class="line"><span class="number">17</span> &#125;</span><br></pre></td></tr></table></figure><p>newTable[i]的引用赋给了e.next，也就是使用了单链表的头插入方式，同一位置上新元素总会被放在链表的头部位置；这样先放在一个索引上的元素终会被放到Entry链的尾部(如果发生了hash冲突的话），这一点和Jdk1.8有区别，下文详解。在旧数组中同一条Entry链上的元素，通过重新计算索引位置后，有可能被放到了新数组的不同位置上。</p><p>下面举个例子说明下扩容过程。假设了我们的hash算法就是简单的用key mod 一下表的大小（也就是数组的长度）。其中的哈希桶数组table的size=2， 所以key = 3、7、5，put顺序依次为 5、7、3。在mod 2以后都冲突在table[1]这里了。这里假设负载因子 loadFactor=1，即当键值对的实际大小size 大于 table的实际大小时进行扩容。接下来的三个步骤是哈希桶数组 resize成4，然后所有的Node重新rehash的过程。</p><img src="/2018/06/05/Java中的HashMap/jdk1.7扩容例图.png" class="rounded" width="400" height="400" title="jdk1.7扩容例图"><p>下面我们讲解下JDK1.8做了哪些优化。经过观测可以发现，我们使用的是2次幂的扩展(指长度扩为原来2倍)，所以，元素的位置要么是在原位置，要么是在原位置再移动2次幂的位置。看下图可以明白这句话的意思，n为table的长度，图（a）表示扩容前的key1和key2两种key确定索引位置的示例，图（b）表示扩容后key1和key2两种key确定索引位置的示例，其中hash1是key1对应的哈希与高位运算结果。</p><img src="/2018/06/05/Java中的HashMap/hashMap1.8哈希算法例图1.png" class="rounded" width="400" height="400" title="hashMap 1.8 哈希算法例图1"><p>元素在重新计算hash之后，因为n变为2倍，那么n-1的mask范围在高位多1bit(红色)，因此新的index就会发生这样的变化:</p><img src="/2018/06/05/Java中的HashMap/hashMap1.8哈希算法例图2.png" class="rounded" width="400" height="400" title="hashMap 1.8 哈希算法例图2"><p>因此，我们在扩充HashMap的时候，不需要像JDK1.7的实现那样重新计算hash，只需要看看原来的hash值新增的那个bit是1还是0就好了，是0的话索引没变，是1的话索引变成“原索引+oldCap”，可以看看下图为16扩充为32的resize示意图</p><img src="/2018/06/05/Java中的HashMap/jdk1.8hashMap扩容例图.png" class="rounded" width="400" height="400" title="jdk1.8 hashMap扩容例图"><p>这个设计确实非常的巧妙，既省去了重新计算hash值的时间，而且同时，由于新增的1bit是0还是1可以认为是随机的，因此resize的过程，均匀的把之前的冲突的节点分散到新的bucket了。这一块就是JDK1.8新增的优化点。有一点注意区别，JDK1.7中rehash的时候，旧链表迁移新链表的时候，如果在新表的数组索引位置相同，则链表元素会倒置，但是从上图可以看出，JDK1.8不会倒置。有兴趣的同学可以研究下JDK1.8的resize源码，写的很赞，如下:</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br></pre></td><td class="code"><pre><span class="line"> <span class="number">1</span> <span class="keyword">final</span> Node&lt;K,V&gt;[] resize() &#123;</span><br><span class="line"> <span class="number">2</span>     Node&lt;K,V&gt;[] oldTab = table;</span><br><span class="line"> <span class="number">3</span>     <span class="keyword">int</span> oldCap = (oldTab == <span class="keyword">null</span>) ? <span class="number">0</span> : oldTab.length;</span><br><span class="line"> <span class="number">4</span>     <span class="keyword">int</span> oldThr = threshold;</span><br><span class="line"> <span class="number">5</span>     <span class="keyword">int</span> newCap, newThr = <span class="number">0</span>;</span><br><span class="line"> <span class="number">6</span>     <span class="keyword">if</span> (oldCap &gt; <span class="number">0</span>) &#123;</span><br><span class="line"> <span class="number">7</span>         <span class="comment">// 超过最大值就不再扩充了，就只好随你碰撞去吧</span></span><br><span class="line"> <span class="number">8</span>         <span class="keyword">if</span> (oldCap &gt;= MAXIMUM_CAPACITY) &#123;</span><br><span class="line"> <span class="number">9</span>             threshold = Integer.MAX_VALUE;</span><br><span class="line"><span class="number">10</span>             <span class="keyword">return</span> oldTab;</span><br><span class="line"><span class="number">11</span>         &#125;</span><br><span class="line"><span class="number">12</span>         <span class="comment">// 没超过最大值，就扩充为原来的2倍</span></span><br><span class="line"><span class="number">13</span>         <span class="keyword">else</span> <span class="keyword">if</span> ((newCap = oldCap &lt;&lt; <span class="number">1</span>) &lt; MAXIMUM_CAPACITY &amp;&amp;</span><br><span class="line"><span class="number">14</span>                  oldCap &gt;= DEFAULT_INITIAL_CAPACITY)</span><br><span class="line"><span class="number">15</span>             newThr = oldThr &lt;&lt; <span class="number">1</span>; <span class="comment">// double threshold</span></span><br><span class="line"><span class="number">16</span>     &#125;</span><br><span class="line"><span class="number">17</span>     <span class="keyword">else</span> <span class="keyword">if</span> (oldThr &gt; <span class="number">0</span>) <span class="comment">// initial capacity was placed in threshold</span></span><br><span class="line"><span class="number">18</span>         newCap = oldThr;</span><br><span class="line"><span class="number">19</span>     <span class="keyword">else</span> &#123;               <span class="comment">// zero initial threshold signifies using defaults</span></span><br><span class="line"><span class="number">20</span>         newCap = DEFAULT_INITIAL_CAPACITY;</span><br><span class="line"><span class="number">21</span>         newThr = (<span class="keyword">int</span>)(DEFAULT_LOAD_FACTOR * DEFAULT_INITIAL_CAPACITY);</span><br><span class="line"><span class="number">22</span>     &#125;</span><br><span class="line"><span class="number">23</span>     <span class="comment">// 计算新的resize上限</span></span><br><span class="line"><span class="number">24</span>     <span class="keyword">if</span> (newThr == <span class="number">0</span>) &#123;</span><br><span class="line"><span class="number">25</span></span><br><span class="line"><span class="number">26</span>         <span class="keyword">float</span> ft = (<span class="keyword">float</span>)newCap * loadFactor;</span><br><span class="line"><span class="number">27</span>         newThr = (newCap &lt; MAXIMUM_CAPACITY &amp;&amp; ft &lt; (<span class="keyword">float</span>)MAXIMUM_CAPACITY ?</span><br><span class="line"><span class="number">28</span>                   (<span class="keyword">int</span>)ft : Integer.MAX_VALUE);</span><br><span class="line"><span class="number">29</span>     &#125;</span><br><span class="line"><span class="number">30</span>     threshold = newThr;</span><br><span class="line"><span class="number">31</span>     <span class="meta">@SuppressWarnings</span>(&#123;<span class="string">"rawtypes"</span>，<span class="string">"unchecked"</span>&#125;)</span><br><span class="line"><span class="number">32</span>         Node&lt;K,V&gt;[] newTab = (Node&lt;K,V&gt;[])<span class="keyword">new</span> Node[newCap];</span><br><span class="line"><span class="number">33</span>     table = newTab;</span><br><span class="line"><span class="number">34</span>     <span class="keyword">if</span> (oldTab != <span class="keyword">null</span>) &#123;</span><br><span class="line"><span class="number">35</span>         <span class="comment">// 把每个bucket都移动到新的buckets中</span></span><br><span class="line"><span class="number">36</span>         <span class="keyword">for</span> (<span class="keyword">int</span> j = <span class="number">0</span>; j &lt; oldCap; ++j) &#123;</span><br><span class="line"><span class="number">37</span>             Node&lt;K,V&gt; e;</span><br><span class="line"><span class="number">38</span>             <span class="keyword">if</span> ((e = oldTab[j]) != <span class="keyword">null</span>) &#123;</span><br><span class="line"><span class="number">39</span>                 oldTab[j] = <span class="keyword">null</span>;</span><br><span class="line"><span class="number">40</span>                 <span class="keyword">if</span> (e.next == <span class="keyword">null</span>)</span><br><span class="line"><span class="number">41</span>                     newTab[e.hash &amp; (newCap - <span class="number">1</span>)] = e;</span><br><span class="line"><span class="number">42</span>                 <span class="keyword">else</span> <span class="keyword">if</span> (e <span class="keyword">instanceof</span> TreeNode)</span><br><span class="line"><span class="number">43</span>                     ((TreeNode&lt;K,V&gt;)e).split(<span class="keyword">this</span>, newTab, j, oldCap);</span><br><span class="line"><span class="number">44</span>                 <span class="keyword">else</span> &#123; <span class="comment">// 链表优化重hash的代码块</span></span><br><span class="line"><span class="number">45</span>                     Node&lt;K,V&gt; loHead = <span class="keyword">null</span>, loTail = <span class="keyword">null</span>;</span><br><span class="line"><span class="number">46</span>                     Node&lt;K,V&gt; hiHead = <span class="keyword">null</span>, hiTail = <span class="keyword">null</span>;</span><br><span class="line"><span class="number">47</span>                     Node&lt;K,V&gt; next;</span><br><span class="line"><span class="number">48</span>                     <span class="keyword">do</span> &#123;</span><br><span class="line"><span class="number">49</span>                         next = e.next;</span><br><span class="line"><span class="number">50</span>                         <span class="comment">// 原索引</span></span><br><span class="line"><span class="number">51</span>                         <span class="keyword">if</span> ((e.hash &amp; oldCap) == <span class="number">0</span>) &#123;</span><br><span class="line"><span class="number">52</span>                             <span class="keyword">if</span> (loTail == <span class="keyword">null</span>)</span><br><span class="line"><span class="number">53</span>                                 loHead = e;</span><br><span class="line"><span class="number">54</span>                             <span class="keyword">else</span></span><br><span class="line"><span class="number">55</span>                                 loTail.next = e;</span><br><span class="line"><span class="number">56</span>                             loTail = e;</span><br><span class="line"><span class="number">57</span>                         &#125;</span><br><span class="line"><span class="number">58</span>                         <span class="comment">// 原索引+oldCap</span></span><br><span class="line"><span class="number">59</span>                         <span class="keyword">else</span> &#123;</span><br><span class="line"><span class="number">60</span>                             <span class="keyword">if</span> (hiTail == <span class="keyword">null</span>)</span><br><span class="line"><span class="number">61</span>                                 hiHead = e;</span><br><span class="line"><span class="number">62</span>                             <span class="keyword">else</span></span><br><span class="line"><span class="number">63</span>                                 hiTail.next = e;</span><br><span class="line"><span class="number">64</span>                             hiTail = e;</span><br><span class="line"><span class="number">65</span>                         &#125;</span><br><span class="line"><span class="number">66</span>                     &#125; <span class="keyword">while</span> ((e = next) != <span class="keyword">null</span>);</span><br><span class="line"><span class="number">67</span>                     <span class="comment">// 原索引放到bucket里</span></span><br><span class="line"><span class="number">68</span>                     <span class="keyword">if</span> (loTail != <span class="keyword">null</span>) &#123;</span><br><span class="line"><span class="number">69</span>                         loTail.next = <span class="keyword">null</span>;</span><br><span class="line"><span class="number">70</span>                         newTab[j] = loHead;</span><br><span class="line"><span class="number">71</span>                     &#125;</span><br><span class="line"><span class="number">72</span>                     <span class="comment">// 原索引+oldCap放到bucket里</span></span><br><span class="line"><span class="number">73</span>                     <span class="keyword">if</span> (hiTail != <span class="keyword">null</span>) &#123;</span><br><span class="line"><span class="number">74</span>                         hiTail.next = <span class="keyword">null</span>;</span><br><span class="line"><span class="number">75</span>                         newTab[j + oldCap] = hiHead;</span><br><span class="line"><span class="number">76</span>                     &#125;</span><br><span class="line"><span class="number">77</span>                 &#125;</span><br><span class="line"><span class="number">78</span>             &#125;</span><br><span class="line"><span class="number">79</span>         &#125;</span><br><span class="line"><span class="number">80</span>     &#125;</span><br><span class="line"><span class="number">81</span>     <span class="keyword">return</span> newTab;</span><br><span class="line"><span class="number">82</span> &#125;</span><br></pre></td></tr></table></figure><h2>线程安全性</h2><p>在多线程使用场景中，应该尽量避免使用线程不安全的HashMap，而使用线程安全的ConcurrentHashMap。那么为什么说HashMap是线程不安全的，下面举例子说明在并发的多线程使用场景中使用HashMap可能造成死循环。代码例子如下(便于理解，仍然使用JDK1.7的环境)：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">HashMapInfiniteLoop</span> </span>&#123;  </span><br><span class="line"></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">static</span> HashMap&lt;Integer,String&gt; map = <span class="keyword">new</span> HashMap&lt;Integer,String&gt;(<span class="number">2</span>，<span class="number">0.75f</span>);  </span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;  </span><br><span class="line">        map.put(<span class="number">5</span>， <span class="string">"C"</span>);  </span><br><span class="line"></span><br><span class="line">        <span class="keyword">new</span> Thread(<span class="string">"Thread1"</span>) &#123;  </span><br><span class="line">            <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">run</span><span class="params">()</span> </span>&#123;  </span><br><span class="line">                map.put(<span class="number">7</span>, <span class="string">"B"</span>);  </span><br><span class="line">                System.out.println(map);  </span><br><span class="line">            &#125;;  </span><br><span class="line">        &#125;.start();  </span><br><span class="line">        <span class="keyword">new</span> Thread(<span class="string">"Thread2"</span>) &#123;  </span><br><span class="line">            <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">run</span><span class="params">()</span> </span>&#123;  </span><br><span class="line">                map.put(<span class="number">3</span>, <span class="string">"A);  </span></span><br><span class="line"><span class="string">                System.out.println(map);  </span></span><br><span class="line"><span class="string">            &#125;;  </span></span><br><span class="line"><span class="string">        &#125;.start();</span></span><br><span class="line"><span class="string">    &#125;  </span></span><br><span class="line"><span class="string">&#125;</span></span><br></pre></td></tr></table></figure><p>其中，map初始化为一个长度为2的数组，loadFactor=0.75，threshold=2*0.75=1，也就是说当put第二个key的时候，map就需要进行resize。<br>通过设置断点让线程1和线程2同时debug到transfer方法(3.3小节代码块)的首行。注意此时两个线程已经成功添加数据。放开thread1的断点至transfer方法的“Entry next = e.next;” 这一行；然后放开线程2的的断点，让线程2进行resize。结果如下图。</p><img src="/2018/06/05/Java中的HashMap/jdk1.7hashMap死循环例图1.png" class="rounded" width="400" height="400" title="hashMap死循环例图1"><p>注意，Thread1的 e 指向了key(3)，而next指向了key(7)，其在线程二rehash后，指向了线程二重组后的链表。</p><p>线程一被调度回来执行，先是执行 newTalbe[i] = e， 然后是e = next，导致了e指向了key(7)，而下一次循环的next = e.next导致了next指向了key(3)。</p><img src="/2018/06/05/Java中的HashMap/jdk1.7hashMap死循环例图2.png" class="rounded" width="400" height="400" title="hashMap死循环例图2"><p>e.next = newTable[i] 导致 key(3).next 指向了 key(7)。注意：此时的key(7).next 已经指向了key(3)， 环形链表就这样出现了。</p><img src="/2018/06/05/Java中的HashMap/jdk1.7hashMap死循环例图4.png" class="rounded" width="400" height="400" title="hashMap死循环例图4"><p>于是，当我们用线程一调用map.get(11)时，悲剧就出现了——Infinite Loop。</p><h2>JDK1.8与JDK1.7的性能对比</h2><p>HashMap中，如果key经过hash算法得出的数组索引位置全部不相同，即Hash算法非常好，那样的话，getKey方法的时间复杂度就是O(1)，如果Hash算法技术的结果碰撞非常多，假如Hash算极其差，所有的Hash算法结果得出的索引位置一样，那样所有的键值对都集中到一个桶中，或者在一个链表中，或者在一个红黑树中，时间复杂度分别为O(n)和O(lgn)。 鉴于JDK1.8做了多方面的优化，总体性能优于JDK1.7</p><h2>参考</h2><ul><li><a href="https://blog.csdn.net/xuefeng0707/article/details/40797085" title="HashMap多线程死循环问题" target="_blank" rel="noopener">CSDN博客频道</a></li><li><a href="https://tech.meituan.com/java-hashmap.html" title="Java 8系列之重新认识HashMap" target="_blank" rel="noopener">美团技术点评</a></li><li><a href="https://www.youtube.com/watch?v=c3RVW3KGIIE" title="How HashMap works in Java? With Animation!! whats new in java8 tutorial" target="_blank" rel="noopener">YouTube视频</a></li></ul>]]></content>
    
    <summary type="html">
    
      
      
        &lt;blockquote&gt;&lt;p&gt;HashMap是Java程序员使用频率最高的用于映射(键值对)处理的数据类型。随着JDK（Java Developmet Kit）版本的更新，JDK1.8对HashMap底层的实现进行了优化，例如引入红黑树的数据结构和扩容的优化等。本文结合JDK1.
      
    
    </summary>
    
      <category term="JAVA" scheme="https://kanper.top/categories/JAVA/"/>
    
    
      <category term="JAVA" scheme="https://kanper.top/tags/JAVA/"/>
    
      <category term="HashMap" scheme="https://kanper.top/tags/HashMap/"/>
    
  </entry>
  
  <entry>
    <title>学习安卓开发&lt;3&gt;</title>
    <link href="https://kanper.top/2018/06/04/%E5%AD%A6%E4%B9%A0%E5%AE%89%E5%8D%93%E5%BC%80%E5%8F%91-3/"/>
    <id>https://kanper.top/2018/06/04/学习安卓开发-3/</id>
    <published>2018-06-04T03:33:46.000Z</published>
    <updated>2018-06-10T02:27:43.914Z</updated>
    
    <content type="html"><![CDATA[<p>从本文开始，将翻译谷歌官方文档，对官网的有些东西进行解释，一方面是增强自己对安卓开发的认识，另一方面是为英文基础普通的开发者提供参考</p><h1>应用组件</h1><p>应用组件是Android应用的基本构建基块。每个组件都是一个不同的点，系统可以通过它浸入你的应用。并非所有组件都是用户的实际入口点，有些组件相互依赖，但每个组件都以实体形式存在，并发挥特定作用-每个组件都是唯一的构建基块，有助于定义应用的总体行为。<br>共有四种不同的应用组件类型，每种类型服务于不同的目的，并且具有定义组件的创建和销毁方式的不同生命周期。<br>以下便是这四种用用组件类型：</p><p><strong>Activity</strong><br>Activity 表示具有用户洁面的单一屏幕。例如，电子邮件应用可能具有一个显示新电子邮件列表的Activity、一个用于撰写电子邮件的Activity以及一个用户阅读电子邮件的Activity。尽管这些Activity 通过协作在电子邮件中形成了一种紧密结合的用户体验，但每一个Activity都独立于其他Activity而存在。因此，其他应用可以启动其中任何一个Activity（如果电子邮件应用允许）。例如，相机应用可以启动电子邮件应用内用户撰写新电子邮件的Activity，以便用户共享图片。</p><p><strong>服务</strong><br>服务是一种在后台运行的组件，用于执行长时间运行的操作或为远程进行执行作业。服务不提供用户界面。例如，当用户位于其他应用中时，服务可能在后台播放音乐或者通过网络获取数据，但不会阻断用户与Activity 的交互。诸如Activity等其他组件可以启动服务，让其运行或者与其绑定以便与其进行交互。</p><p><strong>内容提供程序</strong><br>内容提供程序管理一组共享的应用数据。你可以将数据存储在文件系统、SQLite数据库、网络上或者你的应用程序可以访问的任何其他永久性存储位置。其他应用可以通过内容提供程序查询数据，甚至修改数据（如果内容提供程序允许）。例如，Android系统可以提供管理用户联系人信息的内容提供程序。因此，任何具有适当权限的应用都可以查询内容提供程序的某一部分。（如ContactsContract.Data），以读取和写入有关特定人员的信息。</p><p>内容提供程序也适用于读取和写入你的应用不共享的私有数据。例如，记事本应用可以使用内容提供程序来保存笔记。</p><p><strong>广播接收器</strong><br>广播接收器是一种用于响应系统范围广播通知的组件。许多广播都是由系统发起的，例如，通知屏幕已关闭，电池电量不足或已拍摄图片的广播。应用也可以发起广播，例如，通知其他应用某些数据已经下载至设备，并且可供使用。尽管广播接收器不会显示用户界面，但它们可以创建状态栏通知，在发生广播事件时提醒用户。但广播接收器更为常见的用途只是作为通向其他组件的“通道”，设计用于执行极少量的工作。例如，它可能会基于事件发起一项服务来执行某项工作。</p><p>Android系统设计的独特之处在于，任何应用都可以启动其他应用的组件。例如，如果你想让用户使用设备的相机拍摄照片，很可能有另一个应用可以执行这个操作，那么你的应用就可以利用该应用，而不是开发一个Activity来进行拍摄照片。你不需要集成甚至连接到该相机应用的代码，而是只需要启动拍摄照片的相机应用中的Activity。完成拍摄时，系统甚至会将照片返回你的应用，以便你的使用。对于用户而言，就好像相机真正是你应用的组成部分。</p><p>当系统启动某个组件时，会启动改应用的进程（如果尚未运行），并实例化该组件所需的类。例如，如果你的应用程序启动相机应用中拍摄照片的Activity，则该Activity会在属于相机应用的进程，而不是在你的应用的进程中运行。因此，与大多数其他系统上的应用不同，Android应用并没有单一的入口（例如，没有main()函数）。</p><p>由于系统在单独的进程中运行每一个应用，且其文件权限会限制对其他应用的访问，因此你的应用无法直接启动其他应用中的组件，但是Android系统却可以。因此，想要启动其他应用中的组件，你必须向系统传递一则消息，说明你想启动特定组件的Intent。系统随后便会为你自动该组件。</p><h2>启动组件</h2><p>四种组件类型中的三种-Activity、服务和广播接收器；都是通过名为Intent的异步消息进行启动。Intent会在运行时将各个组件相互绑定（你可以将Intent视为从其他组件请求操作的信使），无论组件属于你的应用还是其他应用。</p><p>Intent使用Intent对象创建，它定义的消息用于启动特定组件或特定类型的组件–Intent可以是显式的，也可以是隐式的。</p><p>对于Activity和服务，Intent定义要执行的操作（例如，“查看”或“发送”某个内容），并且可以指定要执行操作的数据的URI（已经正在启动的组件可能需要了解的信息）。例如，Intent传递的请求可以是启动一个显示图像或者打开网页的Activity。在某些情况下，你可以启动Activity来接收结果，在这种情况下，Activity也会在Intent中返回结果（例如，你可以发出一个Intent，让用户选取某位联系人并将其返回给你，返回Intent包括指向所选联系人的URI）。</p><p>对于广播接收器，Intent只会定义要广播的通知（例如，指示设备电池电量不足的广播只包含指示“电池电量不足”的已知操作字符串）。</p><p>Intent 不会启动另一个组件类型-内容提供程序，后者会在成为ContentResolver的请求目标时启动。内容解析程序通过内容提供程序处理所有直接事务，使得通过提供程序执行事务的组件可以无须执行事务，而是改为咋ContentResolver对象上调用方法，这会在内功提供程序与请求信息的组件之间留出一个抽象层（以确保安全）。</p><p>每种类型的组件有不同的启动方法：</p><ul><li>你可以通过将Intent传递到startActivity()或startActivityForResult()（当你想让Activity返回结果时）来启动Activit（或为其安排新任务）。</li><li>你可以通过将Intent传递到startService()来启动服务（或对执行中的服务下达新指令）。或者，你可以通过将Intent传递到bindService()来绑定到该服务。</li><li>你可以通过将Intent传到到sendBroadcast()、sendOrderedBroadcast()或者sendStickyBroadcast()等方法来发起广播；</li><li>你可以通过在ContentResolver上调用query()来对内容提供程序执行查询。</li></ul><h1>清单文件</h1><p>在Android系统启动应用组件之前，系统必须通过读取应用的AndroidManifest.xml 文件（“清单”文件）确认组件存在。你的应用必须在此文件中声明其所有组件，该文件必须位于应用项目目录的根目录中。</p><p>除了生命应用的组件外，清单文件还有许多其他作用，如：</p><ul><li>确定应用需要的任何用户权限，如互联网访问权限或对用户联系人的读写权限</li><li>根据应用使用的API，声明应用所需的最低API级别</li><li>声明应用使用或需要的硬件和软件功能，例如：相机、蓝牙服务或多触点屏幕</li><li>应用需要链接的API库（Android框架API除外），如Google地图</li><li>其他功能</li></ul><h2>声明组件</h2><p>清单文件的主要任务是告知系统有关应用组件的信息。例如，清单文件可以像下面这样声明Activity：</p><figure class="highlight xml"><figcaption><span>清单文件</span></figcaption><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">manifest</span> <span class="attr">...</span> &gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">application</span> <span class="attr">android:icon</span>=<span class="string">"@drawable/app_icon.png"</span> <span class="attr">...</span> &gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">activity</span> <span class="attr">android:name</span>=<span class="string">"com.example.project.ExampleActivity"</span></span></span><br><span class="line"><span class="tag">                  <span class="attr">android:label</span>=<span class="string">"@string/example_label"</span> <span class="attr">...</span> &gt;</span></span><br><span class="line">        <span class="tag">&lt;/<span class="name">activity</span>&gt;</span></span><br><span class="line">        ...</span><br><span class="line">    <span class="tag">&lt;/<span class="name">application</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">manifest</span>&gt;</span></span><br></pre></td></tr></table></figure><p>在&lt;application&gt;元素中，android:icon 属性指向标识应用的图标所对应的资源。<br>在&lt;activity&gt;元素中，android:name 属性指定Activity子类的完全限定类名，android:label属性指定用做Activity的用户可见标签的字符串。<br>你必须通过以下方式声明所有应用组件：</p><ul><li>Activity的&lt;activity&gt;元素</li><li>服务的&lt;service&gt;元素</li><li>广播接收器的&lt;receiver&gt;元素</li><li>内容提供程序的&lt;provider&gt;元素</li></ul><p>你包括在源代码中，但未在清单文件中声明的Activity、服务和内容提供程序对系统不可见，因此也永远不会运行。不过，广播接收器可以在清单文件中声明或在代码中动态创建（如BroadcastReceiver对象）并通过调用registerReceiver()在系统中注册。</p><h2>声明组件功能</h2><p>如上文启动组件中所述，你可以使用Intent来启动Activity、服务和广播接收器。您可以通过在 Intent 中显式命名目标组件（使用组件类名）来执行此操作。 不过，Intent 的真正强大之处在于隐式 Intent 概念。 隐式 Intent 的作用无非是描述要执行的操作类型（还可选择描述您想执行的操作所针对的数据），让系统能够在设备上找到可执行该操作的组件，并启动该组件。 如果有多个组件可以执行 Intent 所描述的操作，则由用户选择使用哪一个组件。</p><p>系统通过将接收到的Intent与设备上的其他应用的清单文件中提供的 Intent 过滤器进行比较来确定可以响应 Intent 的组件。</p><p>当您在应用的清单文件中声明 Activity 时，可以选择性地加入声明 Activity 功能的 Intent 过滤器，以便响应来自其他应用的 Intent。 您可以通过将 &lt;intent-filter&gt; 元素作为组件声明元素的子项进行添加来为您的组件声明 Intent 过滤器。</p><p>例如，如果您开发的电子邮件应用包含一个用于撰写新电子邮件的 Activity，则可以像下面这样声明一个 Intent 过滤器来响应“send” Intent（以发送新电子邮件）：</p><figure class="highlight xml"><figcaption><span>发送电子邮件清单</span></figcaption><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"></span><br></pre></td></tr></table></figure>]]></content>
    
    <summary type="html">
    
      
      
        &lt;p&gt;从本文开始，将翻译谷歌官方文档，对官网的有些东西进行解释，一方面是增强自己对安卓开发的认识，另一方面是为英文基础普通的开发者提供参考&lt;/p&gt;
&lt;h1&gt;应用组件&lt;/h1&gt;
&lt;p&gt;应用组件是Android应用的基本构建基块。每个组件都是一个不同的点，系统可以通过它浸入你的应用。
      
    
    </summary>
    
      <category term="JAVA" scheme="https://kanper.top/categories/JAVA/"/>
    
      <category term="android" scheme="https://kanper.top/categories/JAVA/android/"/>
    
    
      <category term="JAVA" scheme="https://kanper.top/tags/JAVA/"/>
    
      <category term="移动端" scheme="https://kanper.top/tags/%E7%A7%BB%E5%8A%A8%E7%AB%AF/"/>
    
      <category term="谷歌" scheme="https://kanper.top/tags/%E8%B0%B7%E6%AD%8C/"/>
    
  </entry>
  
  <entry>
    <title>学习安卓开发&lt;2&gt;</title>
    <link href="https://kanper.top/2018/05/15/%E5%AD%A6%E4%B9%A0%E5%AE%89%E5%8D%93%E5%BC%80%E5%8F%91-2/"/>
    <id>https://kanper.top/2018/05/15/学习安卓开发-2/</id>
    <published>2018-05-15T03:24:11.000Z</published>
    <updated>2018-05-15T06:55:04.249Z</updated>
    
    <content type="html"><![CDATA[<h2>安卓hello world</h2><ul><li>选择sdk版本</li><li>调整UI</li><li>连接虚拟机或者真机，采用ADB桥接器</li></ul><h2>安卓activity的生命周期</h2><p>参考文档如下：</p><a href="https://developer.android.com/guide/components/activities/activity-lifecycle" target="_blank" rel="noopener">Activity Lifecycle</a><p>安卓每一个activity相当于Web中的page和about页，一个应用可以有多个activity进行切换</p><img src="/2018/05/15/学习安卓开发-2/activity_lifecycle.png" class="left" width="300" height="400" title="安卓activity生命周期"><h2>安卓进行日志查看</h2><p>在安卓activity其生命周期历程中，可以在其中记录日志,有许多打印方法，都是以其英文表示其日志等级，如:i代表info，e代表error</p><figure class="highlight java"><figcaption><span>andriod日志记录</span></figcaption><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">final</span> String MY_TAG = <span class="string">"message"</span>;</span><br><span class="line"></span><br><span class="line"><span class="meta">@Override</span></span><br><span class="line"><span class="function"><span class="keyword">protected</span> <span class="keyword">void</span> <span class="title">onCreate</span><span class="params">(Bundle savedInstanceState)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">super</span>.onCreate(savedInstanceState);</span><br><span class="line">    setContentView(R.layout.activity_main);</span><br><span class="line">    Log.i(MY_TAG, <span class="string">"onCreate"</span>);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>控制台会打印出关于这个tag标签的日志</p><figure class="highlight plain"><figcaption><span>输出结果</span></figcaption><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"> I/message: onCreate</span><br><span class="line">V/ActivityThread: Performing resume of ActivityRecord&#123;20bcdd8b token=android.os.BinderProxy@206cde68 &#123;top.kanper.application/top.kanper.application.MainActivity&#125;&#125;</span><br><span class="line">D/ActivityThread: ACT-AM_ON_RESUME_CALLED ActivityRecord&#123;20bcdd8b token=android.os.BinderProxy@206cde68 &#123;top.kanper.application/top.kanper.application.MainActivity&#125;&#125;</span><br><span class="line">V/ActivityThread: Resume ActivityRecord&#123;20bcdd8b token=android.os.BinderProxy@206cde68 &#123;top.kanper.application/top.kanper.application.MainActivity&#125;&#125; started activity: false, hideForNow: false, finished: false</span><br><span class="line">V/PhoneWindow: DecorView setVisiblity: visibility = 4 ,Parent =null, this =com.android.internal.policy.impl.PhoneWindow$DecorView&#123;13c53995 I.E..... R.....ID 0,0-0,0&#125;</span><br><span class="line">D/OpenGLRenderer: initialize DisplayEventReceiver 0x55ab808350</span><br></pre></td></tr></table></figure><h2>第一个计算的小程序</h2><ul><li>首先在palette 拖动相应的组建到activity页面中</li><li>然后在对应activity的Java中添加某种触发事件来触发计算结果</li><li>将计算结果呈现</li></ul><figure class="highlight xml"><figcaption><span>activity的xml代码</span></figcaption><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br></pre></td><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">EditText</span></span></span><br><span class="line"><span class="tag">    <span class="attr">android:id</span>=<span class="string">"@+id/editText2"</span></span></span><br><span class="line"><span class="tag">    <span class="attr">android:layout_width</span>=<span class="string">"wrap_content"</span></span></span><br><span class="line"><span class="tag">    <span class="attr">android:layout_height</span>=<span class="string">"wrap_content"</span></span></span><br><span class="line"><span class="tag">    <span class="attr">android:layout_marginStart</span>=<span class="string">"16dp"</span></span></span><br><span class="line"><span class="tag">    <span class="attr">android:layout_marginTop</span>=<span class="string">"44dp"</span></span></span><br><span class="line"><span class="tag">    <span class="attr">android:ems</span>=<span class="string">"10"</span></span></span><br><span class="line"><span class="tag">    <span class="attr">android:hint</span>=<span class="string">"@string/number1"</span></span></span><br><span class="line"><span class="tag">    <span class="attr">android:inputType</span>=<span class="string">"number"</span></span></span><br><span class="line"><span class="tag">    <span class="attr">app:layout_constraintStart_toStartOf</span>=<span class="string">"parent"</span></span></span><br><span class="line"><span class="tag">    <span class="attr">app:layout_constraintTop_toBottomOf</span>=<span class="string">"@+id/editText"</span> /&gt;</span></span><br><span class="line"></span><br><span class="line"><span class="tag">&lt;<span class="name">EditText</span></span></span><br><span class="line"><span class="tag">    <span class="attr">android:id</span>=<span class="string">"@+id/editText3"</span></span></span><br><span class="line"><span class="tag">    <span class="attr">android:layout_width</span>=<span class="string">"wrap_content"</span></span></span><br><span class="line"><span class="tag">    <span class="attr">android:layout_height</span>=<span class="string">"wrap_content"</span></span></span><br><span class="line"><span class="tag">    <span class="attr">android:layout_marginStart</span>=<span class="string">"16dp"</span></span></span><br><span class="line"><span class="tag">    <span class="attr">android:layout_marginTop</span>=<span class="string">"16dp"</span></span></span><br><span class="line"><span class="tag">    <span class="attr">android:ems</span>=<span class="string">"10"</span></span></span><br><span class="line"><span class="tag">    <span class="attr">android:hint</span>=<span class="string">"@string/number2"</span></span></span><br><span class="line"><span class="tag">    <span class="attr">android:inputType</span>=<span class="string">"number"</span></span></span><br><span class="line"><span class="tag">    <span class="attr">app:layout_constraintStart_toStartOf</span>=<span class="string">"parent"</span></span></span><br><span class="line"><span class="tag">    <span class="attr">app:layout_constraintTop_toBottomOf</span>=<span class="string">"@+id/editText2"</span> /&gt;</span></span><br><span class="line"></span><br><span class="line"><span class="tag">&lt;<span class="name">Button</span></span></span><br><span class="line"><span class="tag">    <span class="attr">android:id</span>=<span class="string">"@+id/button"</span></span></span><br><span class="line"><span class="tag">    <span class="attr">android:layout_width</span>=<span class="string">"wrap_content"</span></span></span><br><span class="line"><span class="tag">    <span class="attr">android:layout_height</span>=<span class="string">"wrap_content"</span></span></span><br><span class="line"><span class="tag">    <span class="attr">android:layout_marginStart</span>=<span class="string">"16dp"</span></span></span><br><span class="line"><span class="tag">    <span class="attr">android:layout_marginTop</span>=<span class="string">"24dp"</span></span></span><br><span class="line"><span class="tag">    <span class="attr">android:onClick</span>=<span class="string">"onClickSumButton"</span></span></span><br><span class="line"><span class="tag">    <span class="attr">android:text</span>=<span class="string">"@string/button"</span></span></span><br><span class="line"><span class="tag">    <span class="attr">app:layout_constraintStart_toStartOf</span>=<span class="string">"parent"</span></span></span><br><span class="line"><span class="tag">    <span class="attr">app:layout_constraintTop_toBottomOf</span>=<span class="string">"@+id/textView2"</span> /&gt;</span></span><br><span class="line"></span><br><span class="line"><span class="tag">&lt;<span class="name">TextView</span></span></span><br><span class="line"><span class="tag">    <span class="attr">android:id</span>=<span class="string">"@+id/textView2"</span></span></span><br><span class="line"><span class="tag">    <span class="attr">android:layout_width</span>=<span class="string">"77dp"</span></span></span><br><span class="line"><span class="tag">    <span class="attr">android:layout_height</span>=<span class="string">"27dp"</span></span></span><br><span class="line"><span class="tag">    <span class="attr">android:layout_marginStart</span>=<span class="string">"16dp"</span></span></span><br><span class="line"><span class="tag">    <span class="attr">android:layout_marginTop</span>=<span class="string">"16dp"</span></span></span><br><span class="line"><span class="tag">    <span class="attr">android:text</span>=<span class="string">"@string/result"</span></span></span><br><span class="line"><span class="tag">    <span class="attr">android:textAlignment</span>=<span class="string">"center"</span></span></span><br><span class="line"><span class="tag">    <span class="attr">android:textSize</span>=<span class="string">"24sp"</span></span></span><br><span class="line"><span class="tag">    <span class="attr">app:layout_constraintStart_toStartOf</span>=<span class="string">"parent"</span></span></span><br><span class="line"><span class="tag">    <span class="attr">app:layout_constraintTop_toBottomOf</span>=<span class="string">"@+id/editText3"</span> /&gt;</span></span><br><span class="line"></span><br></pre></td></tr></table></figure><p>接下来是点击事件的Java代码</p><figure class="highlight java"><figcaption><span>点击事件触发的Java代码</span></figcaption><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * 计算2个输入框的总和</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">onClickSumButton</span><span class="params">(View view)</span> </span>&#123;</span><br><span class="line">    EditText editText = findViewById(R.id.editText2);</span><br><span class="line">    EditText editText1 = findViewById(R.id.editText3);</span><br><span class="line">    TextView textView = findViewById(R.id.textView2);</span><br><span class="line"></span><br><span class="line">    <span class="keyword">int</span> sum = Integer.parseInt(editText.getText().toString()) + Integer.parseInt(editText1.getText().toString());</span><br><span class="line"></span><br><span class="line">    textView.setText(Integer.toString(sum));</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>忽略上面的文本框，看看下面的模拟的计算器的结果</p><img src="/2018/05/15/学习安卓开发-2/Screenshot_1526367119.png" class="left" width="300" height="400" title="模拟的安卓计算器">]]></content>
    
    <summary type="html">
    
      
      
        &lt;h2&gt;安卓hello world&lt;/h2&gt;
&lt;ul&gt;
&lt;li&gt;选择sdk版本&lt;/li&gt;
&lt;li&gt;调整UI&lt;/li&gt;
&lt;li&gt;连接虚拟机或者真机，采用ADB桥接器&lt;/li&gt;
&lt;/ul&gt;
&lt;h2&gt;安卓activity的生命周期&lt;/h2&gt;
&lt;p&gt;参考文档如下：&lt;/p&gt;
&lt;a href
      
    
    </summary>
    
      <category term="JAVA" scheme="https://kanper.top/categories/JAVA/"/>
    
      <category term="android" scheme="https://kanper.top/categories/JAVA/android/"/>
    
    
      <category term="JAVA" scheme="https://kanper.top/tags/JAVA/"/>
    
      <category term="移动端" scheme="https://kanper.top/tags/%E7%A7%BB%E5%8A%A8%E7%AB%AF/"/>
    
      <category term="谷歌" scheme="https://kanper.top/tags/%E8%B0%B7%E6%AD%8C/"/>
    
  </entry>
  
  <entry>
    <title>学习安卓开发&lt;1&gt;</title>
    <link href="https://kanper.top/2018/05/14/%E5%AD%A6%E4%B9%A0%E5%AE%89%E5%8D%93%E5%BC%80%E5%8F%91-1/"/>
    <id>https://kanper.top/2018/05/14/学习安卓开发-1/</id>
    <published>2018-05-14T08:23:36.000Z</published>
    <updated>2018-05-14T08:52:58.739Z</updated>
    
    <content type="html"><![CDATA[<blockquote><p>从一个有一定的Java开发去学习android开发比无基础的开发者稍微快一些，在学习android的过程中，可以将Java的知识进行巩固和复习，如果说要进行专业的android开发，则还需要很长一段时间，博主干了4年的Java，大致看了一下安卓的开发，感觉需要1年才能上手</p><footer><strong>kanper</strong></footer></blockquote><h2>安卓 VS android</h2><p>首先，吐槽一下关于安卓和android的区别，很多人也许认为安卓就是android的中文翻译，但是今天我想告诉你，其实不是，安卓现在狭义的讲，已经仅仅指的国内的定制化的安卓系统了，有代表为华为、小米的miui，他们讲安卓定制为符合国人需要，并且有一些恶心的全家桶和广告，让用户不甚其烦，不过还好，很多厂家还是慢慢的有良心，没良心的那些上不了Google play的应用，频繁的在后台唤醒程序，或者干脆吃尽手机资源。</p><p>之前看了知乎上关于安卓续航的文章</p><blockquote><p>当人们在讨论安卓手机掉帧、卡顿、续航变短的时候，常常会接着讨论手机性能不足、电池太小等等硬件相关问题，对手机稍有了解的可能还会说安卓系统的优化不足……但你有没有想过，这一切的根源，极有可能是你每天都要使用的APP。</p><footer><strong>@村姑阳子</strong><cite><a href="https://zhuanlan.zhihu.com/p/26263557" target="_blank" rel="noopener">安卓 & 卡顿 & APP</a></cite></footer></blockquote><p>诚然手机的性能是可以提升用户体验的，那么我们开发者能做些什么呢，少吃一点内存，多用一点缓存？我想这是值得我们开发者深思的问题，安卓并不差，差的是国内浮躁的开发环境，很多时候，应用甚至不考虑用户的感受，强行向用户进行填鸭式广告推销及全家桶推荐，博主是谷粉，喜欢 🌎 谷歌开源纯净的系统，就算开发，也要花钱去专门买一个nexus 5X来进行开发，无他，用着爽，全家桶舒服，墙外的世界不过是一个VPN、shadowsocks就能达到的，google play的世界增加了对app的审核，把用户放在了心上。</p><h2>准备</h2><p>🔔 安卓开发首先需要在机器上安装android studio,这个里面集成了相当多安卓开发的sdk,也对idea用户非常友善<br>🔔 按照Google 官方文档，从第一个activity开始敲起，仔细理解里面的布局，事件等是如何交互的<a href="https://developer.android.com/training/basics/firstapp/" title="构建您的第一个应用" target="_blank" rel="noopener">谷歌开发文档</a></p><h2>收获</h2><p>移动APP的反馈是非常快的，IDE的继承也是相当的方便，得到积极的回馈会非常乐于继续开发的，Let’s Go!</p><h2>参考文档</h2><ul><li><a href="https://developer.android.com/training/basics/firstapp/" title="构建您的第一个应用" target="_blank" rel="noopener">谷歌开发者</a></li></ul>]]></content>
    
    <summary type="html">
    
      
      
        &lt;blockquote&gt;&lt;p&gt;从一个有一定的Java开发去学习android开发比无基础的开发者稍微快一些，在学习android的过程中，可以将Java的知识进行巩固和复习，如果说要进行专业的android开发，则还需要很长一段时间，博主干了4年的Java，大致看了一下安卓的开发
      
    
    </summary>
    
      <category term="JAVA" scheme="https://kanper.top/categories/JAVA/"/>
    
      <category term="android" scheme="https://kanper.top/categories/JAVA/android/"/>
    
    
      <category term="JAVA" scheme="https://kanper.top/tags/JAVA/"/>
    
      <category term="移动端" scheme="https://kanper.top/tags/%E7%A7%BB%E5%8A%A8%E7%AB%AF/"/>
    
      <category term="谷歌" scheme="https://kanper.top/tags/%E8%B0%B7%E6%AD%8C/"/>
    
  </entry>
  
  <entry>
    <title>通过JAVA调用谷歌翻译API</title>
    <link href="https://kanper.top/2018/05/11/%E8%B0%B7%E6%AD%8C%E7%BF%BB%E8%AF%91/"/>
    <id>https://kanper.top/2018/05/11/谷歌翻译/</id>
    <published>2018-05-11T05:59:27.000Z</published>
    <updated>2018-05-11T06:36:11.416Z</updated>
    
    <content type="html"><![CDATA[<blockquote><p>被谷歌ai语音刷屏，昨天看了视频没有&quot;感动.惊喜&quot;，比较淡定，毕竟这是google理所当然能办到的事情，G厂在ai领域早已是领头羊，环境，土壤，公司信奉的价值观缺一不可。最重要的是，那帮&quot;天才&quot;能在理想的环境中做着理想的事情，羡慕古狗</p><footer><strong>kanper</strong></footer></blockquote><h2>闲聊</h2><p>如引文所说的那样，很羡慕谷歌 🐶 的工程师,目前一直在学习安卓，学习安卓不可避免的跟谷歌打交道，服务器快到期了，谷歌也给我发了新的功能邮件，于是就上去看了一下，心想反正以后也会用那些免费的API，索性试试先</p><h2>准备</h2><p>✅ 你可以选择性的安装谷歌SDK开发，不过这个安装之后，可以在本地很方便的利用命令行操作谷歌一些资源<br>🇨🇳 谷歌API对于中文也是十分友好的，自己去看也不错</p><ol><li>首先将谷歌工程中的服务账号的私钥保存到客户机上</li><li>设置GOOGLE_APPLICATION_CREDENTIALS的环境变量指向这个私钥地址</li><li>然后开启一个java工程</li></ol><h2>代码</h2><figure class="highlight java"><figcaption><span>TranslationDemo</span></figcaption><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// Instantiates a client</span></span><br><span class="line">Translate translate = TranslateOptions.getDefaultInstance().getService();</span><br><span class="line"></span><br><span class="line"><span class="comment">// The text to translate</span></span><br><span class="line">String text = <span class="string">"Hello, world! My name is Zelda, you know alipay is popular all around the world,is't it?"</span>;</span><br><span class="line"></span><br><span class="line"><span class="comment">// Translates some text into chinese and japanese</span></span><br><span class="line">Translation translation =</span><br><span class="line">        translate.translate(</span><br><span class="line">                text,</span><br><span class="line">                Translate.TranslateOption.sourceLanguage(<span class="string">"en"</span>),</span><br><span class="line">                Translate.TranslateOption.targetLanguage(<span class="string">"zh-cn"</span>));</span><br><span class="line">Translation translationJapanese =</span><br><span class="line">        translate.translate(</span><br><span class="line">                text,</span><br><span class="line">                Translate.TranslateOption.sourceLanguage(<span class="string">"en"</span>),</span><br><span class="line">                Translate.TranslateOption.targetLanguage(<span class="string">"ja"</span>));</span><br><span class="line"></span><br><span class="line">System.out.printf(<span class="string">"OriginText: %s%n"</span>, text);</span><br><span class="line">System.out.printf(<span class="string">"Translation Chinese: %s%n"</span>, translation.getTranslatedText());</span><br><span class="line">System.out.printf(<span class="string">"Translation Japanese: %s%n"</span>, translationJapanese.getTranslatedText());</span><br></pre></td></tr></table></figure><h2>结果</h2><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line">OriginText: Hello, world! My name is Zelda, you know alipay is popular all around the world,is&apos;t it?</span><br><span class="line">Translation Chinese: 你好，世界！我的名字是塞尔达，你知道支付宝在世界各地都很受欢迎，不是吗？</span><br><span class="line">Translation Japanese: こんにちは世界！私の名前はゼルダです、あなたはアリペイが世界中で人気があることを知っていますか？</span><br><span class="line"></span><br></pre></td></tr></table></figure><h2>后记</h2><p>可以看出，引用谷歌API是十分方便的，很低的时延就可以返回结果，缺点是需要翻墙，在java代码中，还是需要配置代理，或者你可以采用以下代码进行代理</p><figure class="highlight java"><figcaption><span>代理代码</span></figcaption><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">static</span> &#123;</span><br><span class="line">    System.setProperty(<span class="string">"http.proxyHost"</span>, <span class="string">"127.0.0.1"</span>);</span><br><span class="line">    System.setProperty(<span class="string">"http.proxyPort"</span>, <span class="string">"1080"</span>);</span><br><span class="line">    System.setProperty(<span class="string">"https.proxyHost"</span>, <span class="string">"127.0.0.1"</span>);</span><br><span class="line">    System.setProperty(<span class="string">"https.proxyPort"</span>, <span class="string">"1080"</span>);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>总的来说，这些知识为了将来方便的调用第三方接口作出准备</p><h2>参考文档</h2><ul><li><a href="https://cloud.google.com/translate/docs/translating-text#translate-translate-text-java" title="谷歌翻译" target="_blank" rel="noopener">谷歌翻译Translating Text</a></li></ul>]]></content>
    
    <summary type="html">
    
      
      
        &lt;blockquote&gt;&lt;p&gt;被谷歌ai语音刷屏，昨天看了视频没有&amp;quot;感动.惊喜&amp;quot;，比较淡定，毕竟这是google理所当然能办到的事情，G厂在ai领域早已是领头羊，环境，土壤，公司信奉的价值观缺一不可。最重要的是，那帮&amp;quot;天才&amp;quot;能在理想的环境中
      
    
    </summary>
    
      <category term="JAVA" scheme="https://kanper.top/categories/JAVA/"/>
    
      <category term="翻译" scheme="https://kanper.top/categories/JAVA/%E7%BF%BB%E8%AF%91/"/>
    
    
      <category term="JAVA" scheme="https://kanper.top/tags/JAVA/"/>
    
      <category term="谷歌" scheme="https://kanper.top/tags/%E8%B0%B7%E6%AD%8C/"/>
    
      <category term="语言翻译" scheme="https://kanper.top/tags/%E8%AF%AD%E8%A8%80%E7%BF%BB%E8%AF%91/"/>
    
  </entry>
  
  <entry>
    <title>spark处理xml</title>
    <link href="https://kanper.top/2018/05/10/spark%E5%A4%84%E7%90%86xml/"/>
    <id>https://kanper.top/2018/05/10/spark处理xml/</id>
    <published>2018-05-10T06:18:14.000Z</published>
    <updated>2018-05-10T07:06:24.507Z</updated>
    
    <content type="html"><![CDATA[<blockquote><p>当前电信的数据主要还是以xml的形式存储，各大厂返回的数据格式也大多是xml，对于普通的txt行文件，我们可以通过spark流式计算很快的计算出结果，但是也希望通过这种方式准实时的，或者说低时延的将xml解析并存储。传统的做法先解析，再计算，这样浪费了很多时间。</p><footer><strong>kanper</strong><cite>背景交代</cite></footer></blockquote><h2>开发准备</h2><p>首先安装spark开发环境，详情参见</p><blockquote><p>Install steps for Apache Spark on Mac OS X using Homebrew.</p><footer><strong>Roland Groza</strong><cite><a href="https://gist.github.com/rolandjitsu/0d470184c4cebaaf48892448638bbb38" target="_blank" rel="noopener">Apache Spark</a></cite></footer></blockquote><p>spark 安装完毕后，在终端能看到spark启动的logo，则代表spark环境安装成功</p><img src="/2018/05/10/spark处理xml/logo.jpg" class="left" width="400" height="300" title="spark启动logo"><h2>依赖</h2><p>需要添加一些maven依赖，sparkStreaming做流式计算用的，本项目可以不用，spark对sql结构数据的处理和spark-xml解析需要<br>具体的使用可以参考Github<br><a href="https://github.com/databricks/spark-xml" target="_blank" rel="noopener">https://github.com/databricks/spark-xml</a></p><figure class="highlight"><figcaption><span>maven依赖</span></figcaption><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br></pre></td><td class="code"><pre><span class="line">&lt;!-- https:<span class="comment">//mvnrepository.com/artifact/org.apache.spark/spark-streaming --&gt;</span></span><br><span class="line">&lt;dependency&gt;</span><br><span class="line">    &lt;groupId&gt;org.apache.spark&lt;/groupId&gt;</span><br><span class="line">    &lt;artifactId&gt;spark-streaming_2.10&lt;/artifactId&gt;</span><br><span class="line">    &lt;version&gt;1.6.3&lt;/version&gt;</span><br><span class="line">    &lt;exclusions&gt;</span><br><span class="line">        &lt;exclusion&gt;</span><br><span class="line">            &lt;artifactId&gt;reflectasm&lt;/artifactId&gt;</span><br><span class="line">            &lt;groupId&gt;com.esotericsoftware.reflectasm&lt;/groupId&gt;</span><br><span class="line">        &lt;/exclusion&gt;</span><br><span class="line">        &lt;exclusion&gt;</span><br><span class="line">            &lt;artifactId&gt;objenesis&lt;/artifactId&gt;</span><br><span class="line">            &lt;groupId&gt;org.objenesis&lt;/groupId&gt;</span><br><span class="line">        &lt;/exclusion&gt;</span><br><span class="line">        &lt;exclusion&gt;</span><br><span class="line">            &lt;artifactId&gt;minlog&lt;/artifactId&gt;</span><br><span class="line">            &lt;groupId&gt;com.esotericsoftware.minlog&lt;/groupId&gt;</span><br><span class="line">        &lt;/exclusion&gt;</span><br><span class="line">    &lt;/exclusions&gt;</span><br><span class="line">&lt;/dependency&gt;</span><br><span class="line">&lt;!-- https:<span class="comment">//mvnrepository.com/artifact/org.apache.spark/spark-sql --&gt;</span></span><br><span class="line">&lt;dependency&gt;</span><br><span class="line">    &lt;groupId&gt;org.apache.spark&lt;/groupId&gt;</span><br><span class="line">    &lt;artifactId&gt;spark-sql_2.10&lt;/artifactId&gt;</span><br><span class="line">    &lt;version&gt;1.6.3&lt;/version&gt;</span><br><span class="line">&lt;/dependency&gt;</span><br><span class="line">        &lt;dependency&gt;</span><br><span class="line">    &lt;groupId&gt;com.databricks&lt;/groupId&gt;</span><br><span class="line">    &lt;artifactId&gt;spark-xml_2.10&lt;/artifactId&gt;</span><br><span class="line">    &lt;version&gt;0.3.5&lt;/version&gt;</span><br><span class="line">&lt;/dependency&gt;</span><br></pre></td></tr></table></figure><h2>核心代码</h2><figure class="highlight java"><figcaption><span>Spark读取xml文件并转换为RDD</span></figcaption><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// spark 配置</span></span><br><span class="line">SparkConf sparkConf = <span class="keyword">new</span> SparkConf().setAppName(Configurations.APP_NAME).setMaster(Configurations.MASTER);</span><br><span class="line"><span class="comment">// spark 的java上下文</span></span><br><span class="line">JavaSparkContext sc = <span class="keyword">new</span> JavaSparkContext(sparkConf);</span><br><span class="line"><span class="comment">// The entry point for working with structured data (rows and columns) in Spark.</span></span><br><span class="line"><span class="comment">// 结构化数据上下午对象</span></span><br><span class="line">SQLContext sqlContext = <span class="keyword">new</span> SQLContext(sc);</span><br><span class="line">DataFrame df = (<span class="keyword">new</span> XmlReader()).withRowTag(<span class="string">"book"</span>).xmlFile(sqlContext, <span class="string">"your xml file path"</span>);</span><br><span class="line">JavaRDD&lt;Row&gt; rows = df.rdd().toJavaRDD();</span><br><span class="line">rows.foreachPartition(<span class="keyword">new</span> VoidFunction&lt;Iterator&lt;Row&gt;&gt;() &#123;</span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">call</span><span class="params">(Iterator&lt;Row&gt; rowIterator)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">while</span> (rowIterator.hasNext()) &#123;</span><br><span class="line">            Row row = rowIterator.next();</span><br><span class="line">            System.out.println(row.toString());</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;);</span><br></pre></td></tr></table></figure><h2>运行结果</h2><p>原始文件为结构化的xml数据</p><img src="/2018/05/10/spark处理xml/source.jpg" class="left" width="400" height="300" title="xml原始文件"><p>运行后，会解析出对应的xml中的数据</p><img src="/2018/05/10/spark处理xml/result.jpg" class="left" width="400" height="300" title="xml解析后的数据"><p>同时在处理的时候，可以根据需要获取你需要的xml标签值</p><img src="/2018/05/10/spark处理xml/debug.jpg" class="left" width="400" height="300" title="xml解析debug">]]></content>
    
    <summary type="html">
    
      
      
        &lt;blockquote&gt;&lt;p&gt;当前电信的数据主要还是以xml的形式存储，各大厂返回的数据格式也大多是xml，对于普通的txt行文件，我们可以通过spark流式计算很快的计算出结果，但是也希望通过这种方式准实时的，或者说低时延的将xml解析并存储。传统的做法先解析，再计算，这样浪费
      
    
    </summary>
    
      <category term="数据处理" scheme="https://kanper.top/categories/%E6%95%B0%E6%8D%AE%E5%A4%84%E7%90%86/"/>
    
      <category term="数据" scheme="https://kanper.top/categories/%E6%95%B0%E6%8D%AE%E5%A4%84%E7%90%86/%E6%95%B0%E6%8D%AE/"/>
    
    
      <category term="spark" scheme="https://kanper.top/tags/spark/"/>
    
      <category term="xml处理" scheme="https://kanper.top/tags/xml%E5%A4%84%E7%90%86/"/>
    
      <category term="大数据" scheme="https://kanper.top/tags/%E5%A4%A7%E6%95%B0%E6%8D%AE/"/>
    
  </entry>
  
  <entry>
    <title>日本旅行</title>
    <link href="https://kanper.top/2018/05/08/japan/"/>
    <id>https://kanper.top/2018/05/08/japan/</id>
    <published>2018-05-08T01:58:13.000Z</published>
    <updated>2018-05-08T06:27:27.284Z</updated>
    
    <content type="html"><![CDATA[<blockquote><p>日本國（日语：日本国／にっぽんこく／にほんこく Nippon-koku／Nihon-koku */?），通稱日本，為位於東亞的島嶼國家，由日本列島、琉球群島和伊豆－小笠原群島等6,852個島嶼組成[11]，面積約37.8万平方公里[12]。國土全境被太平洋及其緣海環抱，西鄰朝鮮半島及俄罗斯，北面堪察加半島，西南為中國東部及臺灣。人口達1.26億[7]，居於世界各國第10位，當中逾3,500萬以上的人口居住於首都東京都與周邊數縣構成的首都圈，為世界最大的都市圈[13]。政體施行議會制君主立憲制，君主天皇為日本國家與國民的象徵，實際的政治權力則由國會（參眾兩院）、以及首相所領導的內閣掌理，最高法院為最高裁判所[14]。</p><footer><strong>wiki</strong><cite><a href="https://zh.wikipedia.org/wiki/%E6%97%A5%E6%9C%AC" target="_blank" rel="noopener">日本</a></cite></footer></blockquote><h2>前期准备</h2><ul><li>护照办理</li><li>签证办理，签证比较贵，差不多2个人要700左右</li><li>兑换日币，人民币对日元的汇率比较大，看准汇率比较低的那天多兑一点日币，每个人出国不能兑换超过5000RMB等值日币，请相信我，你兑多少花多少</li><li>准备Google地图，Google翻译，日本的地铁很复杂，没有地图，加上语言的不通，会很难</li><li>酒店预定，机票预定，建议7月份或者3月份去，机票便宜，7月份日本打折季</li></ul><h2>行程规划</h2><p>这次自由行主要去关西地区，如果进行日本国周游，需要半个月时间，关西地区和关东地区比较远，地图上可以看出日本是一个狭长的岛国。<br>成都-大阪-京都-伊豆-东京</p><h2>大阪</h2><p>大阪必去的地点-环球影城，环球影城的人气很旺，不仅是外国游客的打卡地点，也是日本本国年轻人亲睐的地方，题外话，日本学生不用上课的吗，工作日也能看到大量的日本学生。环球影城的票可以在某宝购买，也可以到景区排队购买，票分普通和VIP，区别就是排队和快速通道，建议购买自己喜欢的项目的快速票，可以玩的尽兴一点，否则一个项目排队1小时，还是很熬人的。比较热门的项目有：飞天翼龙、哈利波特、小黄人、侏罗纪公园等<br>哈利波特城堡</p><img src="/2018/05/08/japan/IMG_1235.JPG" class="rounded" width="500" height="400" title="哈利波特1"><img src="/2018/05/08/japan/IMG_1475.JPG" class="rounded" width="500" height="400" title="哈利波特2"><img src="/2018/05/08/japan/IMG_9204.JPG" class="rounded" width="500" height="400" title="哈利波特0"><h2>京都</h2><p>京都是日本文化非常浓厚的城市，城市中随处可见身着和服的妹子，也可以看到樱花，可以体会京都的古建筑，博主主要去了伏见稻和神社，京都还有许多神社，都很值得去，他们的风俗保持的比较好，之前看的&lt;你的名字&gt;中的口嚼酒，还有明清时期的朱红色的砖瓦，很适合拍照。<br><strong>京都的建筑</strong></p><img src="/2018/05/08/japan/京都建筑.JPG" class="rounded" width="300" height="400" title="京都建筑"><p><strong>伏见稻荷神社，天气意外的好呢，他们这里的人在舞龙，但不知道是不是舞龙，一种仪式</strong></p><img src="/2018/05/08/japan/伏见稻荷.JPG" class="rounded" width="300" height="400" title="伏见稻荷"><p><strong>神社中的像明清建筑的合院</strong></p><img src="/2018/05/08/japan/伏见稻荷1.JPG" class="rounded" width="300" height="400" title="伏见稻荷明清合院"><p><strong>神社中的寺庙temple</strong></p><img src="/2018/05/08/japan/伏见稻荷2.JPG" class="rounded" width="300" height="400" title="伏见稻荷寺庙"><h2>伊豆</h2><p>知道伊豆是因为川端康成的文章–&lt;伊豆的舞女&gt;，伊豆不止有舞女，伊豆更重要的是伊豆的温泉，推荐购买周游券，伊豆半岛整个岛上都分布着温泉，从修善寺往海岸线箱根铁道都有景点，景点比较多，但是每个景点都比较小，这里的铁路只通达修善寺，修善寺伊东地区都没有火车，只能乘坐大巴车，如果购买了周游券，可以在2天之内前往任何景点<br>推荐入住 汤岛龙田旅馆，很不错的，吃饱休息好了，才有力气旅行。<br><strong>汤岛龙田旅馆</strong></p><img src="/2018/05/08/japan/龙田旅馆.JPG" class="rounded" width="300" height="400" title="龙田旅馆"><img src="/2018/05/08/japan/龙田旅馆0.JPG" class="rounded" width="300" height="400" title="龙田旅馆0"><p><strong>龙田旅馆的早餐</strong></p><img src="/2018/05/08/japan/丰盛的早餐.JPG" class="rounded" width="400" height="300" title="丰盛的早餐"><img src="/2018/05/08/japan/丰盛的早餐0.JPG" class="rounded" width="400" height="300" title="丰盛的早餐0"><img src="/2018/05/08/japan/豆花.JPG" class="rounded" width="400" height="300" title="豆花"><p><strong>龙田旅馆的主食</strong></p><img src="/2018/05/08/japan/糯米牛肉.JPG" class="rounded" width="300" height="400" title="糯米牛肉"><img src="/2018/05/08/japan/糯米牛肉0.JPG" class="rounded" width="400" height="300" title="糯米牛肉0"><img src="/2018/05/08/japan/芥末凉虾.JPG" class="rounded" width="300" height="400" title="芥末凉虾"><img src="/2018/05/08/japan/芥末凉虾0.JPG" class="rounded" width="300" height="400" title="芥末凉虾0"><p><strong>龙田旅馆的温泉</strong></p><img src="/2018/05/08/japan/森林温泉.JPG" class="rounded" width="300" height="400" title="森林温泉"><img src="/2018/05/08/japan/森林温泉0.JPG" class="rounded" width="400" height="300" title="森林温泉0"><img src="/2018/05/08/japan/竹林温泉.JPG" class="rounded" width="400" height="300" title="竹林温泉"><p><strong>天城山修善寺周游</strong></p><img src="/2018/05/08/japan/修善寺.JPG" class="rounded" width="300" height="400" title="修善寺"><img src="/2018/05/08/japan/修善寺0.JPG" class="rounded" width="400" height="300" title="修善寺0"><img src="/2018/05/08/japan/修善寺1.JPG" class="rounded" width="300" height="400" title="修善寺1"><img src="/2018/05/08/japan/海岸线.JPG" class="rounded" width="300" height="400" title="海岸线"><h2>东京</h2><p>东京不热，哈哈，东京有一个秋叶原，宅男天堂，博主在这里买了一款红蓝任天堂switch，感动到哭，东京很适合购物shopping，药妆把常用的往袋子里塞就好了，回国不亏。<br>东京上野公园可以看到樱花，他们管赏樱花的人叫做<em>花见客</em>，也是挺有意思的，公园里非常干净，不仅是日本本国的人来赏樱，也有许多外国游客，大家都很有礼貌，东西吃完了不会乱扔，做文明的花见客，哈哈</p><h2>后记</h2><p>日本玩了7天，花了不少money，主要是买的东西太多，东京不愧为剁手胜地。<br>总结的经验教训如下：</p><ul><li>有周游券一定要买，划算！</li><li>寄放行李箱收费一次性的，找一个大点的箱子寄放行李，划算，手里不要拿太多东西，累</li><li>酒店都很小，别想着住大房间，除非在乡下</li><li>乡下风很冷，多穿衣服</li><li>每天的汇率都不一样，挑一天汇率好的刷卡消费吧</li><li>地铁乘坐很便捷，价格不美丽，建议西瓜卡，用不完的走的时候可以去便利店刷</li><li>一定要整理好你要买的东西，不然面对玲琅满目的商品，你会不知道你买啥，提前在国内了解好，针对性的购买（某些爆款就不必了，你排队也不一定买得到，吐槽日币的专柜！）</li><li>地铁注意看沿途站，有的火车或者地铁，中途可能不会停靠你想下的站</li><li>遇到问题多请教站台的老大爷，老大爷虽然英文不太好，但是会细心的给你指导路线</li></ul>]]></content>
    
    <summary type="html">
    
      
      
        &lt;blockquote&gt;&lt;p&gt;日本國（日语：日本国／にっぽんこく／にほんこく Nippon-koku／Nihon-koku */?），通稱日本，為位於東亞的島嶼國家，由日本列島、琉球群島和伊豆－小笠原群島等6,852個島嶼組成[11]，面積約37.8万平方公里[12]。國土全境被
      
    
    </summary>
    
      <category term="旅行" scheme="https://kanper.top/categories/%E6%97%85%E8%A1%8C/"/>
    
    
      <category term="日本" scheme="https://kanper.top/tags/%E6%97%A5%E6%9C%AC/"/>
    
      <category term="旅行" scheme="https://kanper.top/tags/%E6%97%85%E8%A1%8C/"/>
    
  </entry>
  
  <entry>
    <title>BootStrap学习</title>
    <link href="https://kanper.top/2018/05/07/Bootstrap%E5%AD%A6%E4%B9%A0/"/>
    <id>https://kanper.top/2018/05/07/Bootstrap学习/</id>
    <published>2018-05-07T03:21:49.000Z</published>
    <updated>2018-05-07T07:18:25.000Z</updated>
    
    <content type="html"><![CDATA[<h2>1.准备</h2><h3>CDN启动：</h3><figure class="highlight html"><figcaption><span>CDN</span></figcaption><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">link</span> <span class="attr">rel</span>=<span class="string">"stylesheet"</span> <span class="attr">href</span>=<span class="string">"https://cdn.rawgit.com/twbs/bootstrap/v4-dev/dist/css/bootstrap.css"</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">script</span> <span class="attr">src</span>=<span class="string">"https://cdn.bootcss.com/jquery/2.1.4/jquery.min.js"</span>&gt;</span><span class="undefined"></span><span class="tag">&lt;/<span class="name">script</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">script</span> <span class="attr">src</span>=<span class="string">"https://cdn.rawgit.com/twbs/bootstrap/v4-dev/dist/js/bootstrap.js"</span>&gt;</span><span class="undefined"></span><span class="tag">&lt;/<span class="name">script</span>&gt;</span></span><br></pre></td></tr></table></figure><p>其余可以采用本地连接方式</p><p><strong>HTML5 doctype</strong></p><p>需要使用HTML5引导，否则将会看到不完整的样式，包括它不会造成太大的问题</p><p><strong>移动优先</strong></p><pre><code>&lt;meta name=&quot;viewport&quot; content=&quot;width=device-width, initial-scale=1&quot;&gt;</code></pre><h2>2.布局</h2><p>除了原有内置的许多栅格系统之外，bootstrap还引入了container容器<br><img src="http://i.imgur.com/DtuD6ws.png" alt=""></p><p>左右断点转变，也就是未填充满，当class引入为.container-fluid则无论何时100%填充，经测试：.container左右留白，自适应，.container-fluid满填充，自适应</p><pre><code>&lt;div class=&quot;container&quot;&gt;  &lt;!-- Content here --&gt;&lt;/div&gt;</code></pre><h2>3.内容</h2><h3>标题和段落</h3><p><img src="http://i.imgur.com/zFzzs1L.png" alt=""></p><h3>列表</h3><p><img src="http://i.imgur.com/HimpQY2.png" alt=""></p><h3>表格</h3><p><img src="http://i.imgur.com/ExQoKWg.png" alt=""></p><h3>表单</h3><p><img src="http://i.imgur.com/GmAaEHr.png" alt=""></p><h2>4.组件</h2><h3>按钮</h3><p>新的bootstrap在原来的按钮风格上，添加了移出和移入效果，很简单，仅仅需要添加.btn-*-outline；按钮大小仍然通过-lg/-sm调节</p><blockquote><p>对于a标签同样适用，只是在class风格中添加active，对于禁用元素，传统按钮和CSS属性上写disabled，a标签需要置于class中.disabled</p></blockquote><p><img src="http://i.imgur.com/hKeVL1C.png" alt=""></p><p><img src="http://i.imgur.com/A5wEDnI.png" alt=""></p><p>autocomplete：其含义代表是否让浏览器自动记录之前输入的值，默认为on，设置为off后，会取消默认输入的值</p><p>其他按钮组和老版本bootstrap一致，单选框/复选框组/按钮组/按钮下拉框等，没有改变</p><h3>表单</h3><p><img src="http://i.imgur.com/iEVWDOG.png" alt=""></p><p>一行显示label和input与原来一致，要采用栅格系统，可以用如下代码</p><pre><code>&lt;div class=&quot;form-group row&quot;&gt;    &lt;label for=&quot;inputEmail3&quot; class=&quot;col-sm-2 form-control-label&quot;&gt;Email&lt;/label&gt;    &lt;div class=&quot;col-sm-10&quot;&gt;      &lt;input type=&quot;email&quot; class=&quot;form-control&quot; id=&quot;inputEmail3&quot; placeholder=&quot;Email&quot;&gt;    &lt;/div&gt;&lt;/div&gt;</code></pre><p><img src="http://i.imgur.com/8KPGD7t.png" alt=""></p><p>表单的其余的，诸如大小/可用性/帮助文字和之前版本一致</p><pre><code>&lt;small class=&quot;text-muted&quot;&gt;  Some inline text with a small tag looks like this.&lt;/small&gt;</code></pre><h4>表单验证</h4><pre><code>&lt;div class=&quot;form-group has-success&quot;&gt;  &lt;label class=&quot;control-label&quot; for=&quot;inputSuccess1&quot;&gt;Input with success&lt;/label&gt;  &lt;input type=&quot;text&quot; class=&quot;form-control form-control-success&quot; id=&quot;inputSuccess1&quot;&gt;&lt;/div&gt;</code></pre><p><img src="http://i.imgur.com/mbVxJ0o.png" alt=""></p><h3>卡片</h3><pre><code>&lt;div class=&quot;card&quot;&gt;  &lt;img class=&quot;card-img-top&quot; data-src=&quot;holder.js/100%x180/&quot; alt=&quot;Card image cap&quot;&gt;  &lt;div class=&quot;card-block&quot;&gt;    &lt;h4 class=&quot;card-title&quot;&gt;Card title&lt;/h4&gt;    &lt;p class=&quot;card-text&quot;&gt;Some quick example text to build on the card title and make up the bulk of the card's content.&lt;/p&gt;    &lt;a href=&quot;#&quot; class=&quot;btn btn-primary&quot;&gt;Button&lt;/a&gt;  &lt;/div&gt;&lt;/div&gt;</code></pre><p><img src="http://i.imgur.com/ToXQdpk.png" alt=""></p><h3>导航栏/导航条</h3><h3>页码条</h3><h3>进度条</h3><h3>列表组</h3><h3>模态框</h3><h3>锚连接按钮</h3><h3>按钮提示</h3><h3>对话框提示</h3><h3>轮播</h3><pre><code>&lt;div id=&quot;carousel-example-generic&quot; class=&quot;carousel slide&quot; data-ride=&quot;carousel&quot;&gt;  &lt;ol class=&quot;carousel-indicators&quot;&gt;    &lt;li data-target=&quot;#carousel-example-generic&quot; data-slide-to=&quot;0&quot; class=&quot;active&quot;&gt;&lt;/li&gt;    &lt;li data-target=&quot;#carousel-example-generic&quot; data-slide-to=&quot;1&quot;&gt;&lt;/li&gt;    &lt;li data-target=&quot;#carousel-example-generic&quot; data-slide-to=&quot;2&quot;&gt;&lt;/li&gt;  &lt;/ol&gt;  &lt;div class=&quot;carousel-inner&quot; role=&quot;listbox&quot;&gt;    &lt;div class=&quot;carousel-item active&quot;&gt;      &lt;img data-src=&quot;holder.js/900x500/auto/#777:#555/text:First slide&quot; alt=&quot;First slide&quot;&gt;    &lt;/div&gt;    &lt;div class=&quot;carousel-item&quot;&gt;      &lt;img data-src=&quot;holder.js/900x500/auto/#666:#444/text:Second slide&quot; alt=&quot;Second slide&quot;&gt;    &lt;/div&gt;    &lt;div class=&quot;carousel-item&quot;&gt;      &lt;img data-src=&quot;holder.js/900x500/auto/#555:#333/text:Third slide&quot; alt=&quot;Third slide&quot;&gt;    &lt;/div&gt;  &lt;/div&gt;  &lt;a class=&quot;left carousel-control&quot; href=&quot;#carousel-example-generic&quot; role=&quot;button&quot; data-slide=&quot;prev&quot;&gt;    &lt;span class=&quot;icon-prev&quot; aria-hidden=&quot;true&quot;&gt;&lt;/span&gt;    &lt;span class=&quot;sr-only&quot;&gt;Previous&lt;/span&gt;  &lt;/a&gt;  &lt;a class=&quot;right carousel-control&quot; href=&quot;#carousel-example-generic&quot; role=&quot;button&quot; data-slide=&quot;next&quot;&gt;    &lt;span class=&quot;icon-next&quot; aria-hidden=&quot;true&quot;&gt;&lt;/span&gt;    &lt;span class=&quot;sr-only&quot;&gt;Next&lt;/span&gt;  &lt;/a&gt;&lt;/div&gt;</code></pre><p><img src="http://i.imgur.com/n0WfJE9.png" alt=""></p>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h2&gt;1.准备&lt;/h2&gt;
&lt;h3&gt;CDN启动：&lt;/h3&gt;
&lt;figure class=&quot;highlight html&quot;&gt;&lt;figcaption&gt;&lt;span&gt;CDN&lt;/span&gt;&lt;/figcaption&gt;&lt;table&gt;&lt;tr&gt;&lt;td class=&quot;gutter&quot;&gt;&lt;pre&gt;&lt;sp
      
    
    </summary>
    
      <category term="前端" scheme="https://kanper.top/categories/%E5%89%8D%E7%AB%AF/"/>
    
      <category term="CSS" scheme="https://kanper.top/categories/%E5%89%8D%E7%AB%AF/CSS/"/>
    
    
      <category term="bootstrap" scheme="https://kanper.top/tags/bootstrap/"/>
    
  </entry>
  
  <entry>
    <title>Hello World</title>
    <link href="https://kanper.top/2018/05/04/hello-world/"/>
    <id>https://kanper.top/2018/05/04/hello-world/</id>
    <published>2018-05-04T01:21:16.598Z</published>
    <updated>2018-05-04T01:21:16.598Z</updated>
    
    <content type="html"><![CDATA[<p>Welcome to <a href="https://hexo.io/" target="_blank" rel="noopener">Hexo</a>! This is your very first post. Check <a href="https://hexo.io/docs/" target="_blank" rel="noopener">documentation</a> for more info. If you get any problems when using Hexo, you can find the answer in <a href="https://hexo.io/docs/troubleshooting.html" target="_blank" rel="noopener">troubleshooting</a> or you can ask me on <a href="https://github.com/hexojs/hexo/issues" target="_blank" rel="noopener">GitHub</a>.</p><h2>Quick Start</h2><h3>Create a new post</h3><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">$ hexo new <span class="string">"My New Post"</span></span><br></pre></td></tr></table></figure><p>More info: <a href="https://hexo.io/docs/writing.html" target="_blank" rel="noopener">Writing</a></p><h3>Run server</h3><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">$ hexo server</span><br></pre></td></tr></table></figure><p>More info: <a href="https://hexo.io/docs/server.html" target="_blank" rel="noopener">Server</a></p><h3>Generate static files</h3><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">$ hexo generate</span><br></pre></td></tr></table></figure><p>More info: <a href="https://hexo.io/docs/generating.html" target="_blank" rel="noopener">Generating</a></p><h3>Deploy to remote sites</h3><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">$ hexo deploy</span><br></pre></td></tr></table></figure><p>More info: <a href="https://hexo.io/docs/deployment.html" target="_blank" rel="noopener">Deployment</a></p>]]></content>
    
    <summary type="html">
    
      
      
        &lt;p&gt;Welcome to &lt;a href=&quot;https://hexo.io/&quot; target=&quot;_blank&quot; rel=&quot;noopener&quot;&gt;Hexo&lt;/a&gt;! This is your very first post. Check &lt;a href=&quot;https://hexo.
      
    
    </summary>
    
    
  </entry>
  
  <entry>
    <title>越南旅行</title>
    <link href="https://kanper.top/2017/02/07/vietnam/"/>
    <id>https://kanper.top/2017/02/07/vietnam/</id>
    <published>2017-02-07T01:21:17.000Z</published>
    <updated>2018-05-08T03:40:24.164Z</updated>
    
    <content type="html"><![CDATA[<blockquote><p>越南社會主義共和國（越南语：Cộng hòa xã hội chủ nghĩa Việt Nam／共和社會主義越南 关于这个音频文件 聆聽 帮助·信息），通稱越南（越南语：Việt Nam／越南），是位於东南亚中南半島東端的社会主义国家，北邻中國，西接柬埔寨和老挝，拥有超過9,500万人口，位居世界第15名。越南的首都是河内，最大城市是胡志明市。越南实行一黨制，执政党越南共产党是目前越南境内唯一的合法政党。越南為東南亞國家聯盟[3][4]、世界贸易组织、亚洲太平洋经济合作组织及法语圈国际组织成員，是未来11国之一。</p><footer><strong>wiki</strong><cite><a href="https://zh.wikipedia.org/wiki/%E8%B6%8A%E5%8D%97" target="_blank" rel="noopener">越南</a></cite></footer></blockquote><h2>前期准备</h2><ul><li>护照办理</li><li>签证办理</li><li>越币兑换，出国刷卡收取手续费，中国和访问国都将收取</li><li>行程规划: 胡志明市-潘切-美奈-芽庄-胡志明市</li></ul><p>越南是一个80年代既视感的中国，某些情况下，越南的发展跟中国比较相似，都是社会主义国家，越南的摩托大军真的是嗨森到爆，租一个摩托车骑在两边都是红白沙漠的柏油路上，很有爸爸妈妈上个世纪的那种感觉，哈哈</p><h2>胡志明市</h2><p>胡志明市是一个很干净的城市，街道和国内二线城市差不多，街道上穿越的摩托大军，让你怀疑你穿越到了80年代的中国，胡志明市是一个法国殖民过的地区，城市还保留了许多教堂，哦对了，胡志明市的打卡小吃，法棍三明治，难吃的要死，不过王小妹还是要吃，讲真这里没什么好吃的东西，非要说，牛奶很便宜，可以喝个爽，大概与这里还是农业为主有关系吧；<br>随手一拍都是法式建筑</p><img src="/2017/02/07/vietnam/粉红教堂.png" class="left" width="300" height="400" title="粉红教堂"><h2>美奈</h2><p>越南的交通很差，没有火车，没有高速，或者说有高速，高速开50km/h的那种，半路上还比较颠簸，实在是向往美奈那种安静的小城，于是和王小妹坐了sleeping bus前往美奈，美奈的海鲜你可以当作不要钱的去吃，反正越南的消费比海南三亚便宜，no care。住宿很便宜，贾斯丁戴毡酒店，住2天有游泳池，房间很大，靠海，私人海滩，住2天也不到1000软妹币，挺划算的<br>图1为美奈的落日；图2为美奈的旭日；图3是美奈比较有名的红白沙滩</p><img src="/2017/02/07/vietnam/海边夕阳.png" class="left" width="300" height="400" title="海边夕阳"><img src="/2017/02/07/vietnam/晨跑.png" class="left" width="300" height="400" title="晨跑"><img src="/2017/02/07/vietnam/丢失的草帽.png" class="left" width="300" height="400" title="丢失的草帽"><img src="/2017/02/07/vietnam/IMG_0898.jpg" class="left" width="300" height="400" title="贾斯丁"><h2>芽庄</h2><p>芽庄有发达的旅游业，这里的食物比较丰富，从印度咖喱到中国火锅，应有尽有，缺点是是人特别的多，想找一个人比较少的地方拍照都不好找。<br>芽庄算越南中等发达的城市了，他们的街道是这样的</p><img src="/2017/02/07/vietnam/IMG_1445.JPG" class="left" width="300" height="400" title="芽庄"><p>他们的房屋是这样的</p><img src="/2017/02/07/vietnam/IMG_1403.JPG" class="left" width="300" height="400" title="芽庄"><p>新年了，希望我和王小妹都能心想事成</p><img src="/2017/02/07/vietnam/IMG_1482.JPG" class="left" width="300" height="400" title="me"><img src="/2017/02/07/vietnam/IMG_1480.jpg" class="left" width="300" height="400" title="王小妹"><h2>后记</h2><p>越南还是很适合旅游的一个国家，国家相对比较安全，大城市也好乡村也罢，摩托车都是主要的交通工具，博主和王小妹基本靠租摩托车沿着海岸线游玩，就这样就能耗掉一天的时间，海风很咸，起得早去海滩边走走吧，去早市淘点海鲜中午饱餐一顿，这种原始慢生活的节奏，也许回国以后很难体会得到吧！<br>还要去越南的小伙伴注意了，划重点，划重点～</p><ol><li>防晒准备，越南很晒</li><li>消费不是很贵，不用兑换太多现金，很多地方不能刷卡，人均100一天的伙食就够了（2017年）</li><li>一定要想好去哪些地方，越南的交通相当不方便，为了去太多地方而辗转在路上，不值得，在一个地方悠闲的玩比较好</li><li>拉肚子的药，博主有准备，但是没能用上，这个地方的杀菌工艺还是比较原始的，你懂的</li><li>去吃barcu海鲜的时候，一定砍价，虽然不贵，主要是他们喜欢宰外国客人</li></ol>]]></content>
    
    <summary type="html">
    
      
      
        &lt;blockquote&gt;&lt;p&gt;越南社會主義共和國（越南语：Cộng hòa xã hội chủ nghĩa Việt Nam／共和社會主義越南 关于这个音频文件 聆聽 帮助·信息），通稱越南（越南语：Việt Nam／越南），是位於东南亚中南半島東端的社会主义国家，北邻中國，西
      
    
    </summary>
    
      <category term="旅行" scheme="https://kanper.top/categories/%E6%97%85%E8%A1%8C/"/>
    
    
      <category term="旅行" scheme="https://kanper.top/tags/%E6%97%85%E8%A1%8C/"/>
    
      <category term="越南" scheme="https://kanper.top/tags/%E8%B6%8A%E5%8D%97/"/>
    
  </entry>
  
</feed>
